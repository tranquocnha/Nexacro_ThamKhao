<?xml version="1.0" encoding="utf-8"?>
<Script type="xscript4.0"><![CDATA[

//////////////////////////////////////////////////////////////////////////////////
// 기본함수와의 구별을 위해 첫글자를 대문자로 하였음
// 함수설명 부분에서 Parameter에 있는 (옵션)은 넣어도 되고 안 넣어도 된다는 의미임
// Parameter에 있는 첫글자(예 : nWidth에서의 n)의미 ==> 
//              s = 문자열, n = 숫자형, b = Bool, o = Object, a = Array
// 1. Parameter처리 원칙
//    1) Parameter가 null일 경우 
//       (1) Default처리가 있으면 Default처리 했음 --> Comment참조
//       (2) Default처리가 없는 경우는 아래 실패시 Return처리 원칙에 따름
// 2. 실패시 Return처리 원칙 ( 되도록 null이 return되지 않도록 처리, null되면 죽는 수가 생길 수 있으니까 )
//    1) 문자열 Return의 경우 = ""
//    2) 숫자 Return의 경우 = -1 ( 성공이 0이상인 경우 ), 
//							  NaN ( 성공이 모든 숫자일 경우 )
//    3) Array Return의 경우  = 빈 Array(즉, arr.length=0) 
//    4) Object Return의 경우 = null
//	  5) Boolean Return의 경우 = false
//////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// String & Number Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    입력값이 null에 해당하는 경우 모두를 한번에 체크한다.
 ★ Parameter 
    1. sValue : 체크할 문자열( 예 : null 또는 undefined 또는 "" 또는 "abc" )
 ★ return 
    - sValue가 undefined, null, NaN, "", Array.length = 0인 경우 = true
    - 이외의 경우 = false
******************************************************************************/
function IsNull(sValue)
{
	if( new String(sValue).valueOf() == "undefined") 
		return true;
	if( sValue == null )
		return true;
	if( ("x"+sValue == "xNaN") && ( new String(sValue.length).valueOf() == "undefined" ) )
		return true;
	if( sValue.length == 0 )
		return true;
	return false;
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별하여 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "bb" )
    3. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 4 )
    - 실패 = -1
 ******************************************************************************/
function Pos(sOrg, sFind, nStart)
{
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;
	if( IsNull(nStart) )		nStart = 0;
		
	return sOrg.indexOf(sFind, nStart);
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별없이 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "bb" )
    3. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )    
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function PosCase(sOrg, sFind, nStart)
{
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;
	if( IsNull(nStart) )		nStart = 0;
	
	return sOrg.toLowerCase().indexOf(sFind.toLowerCase(), nStart);
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별하여 거꾸로 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "BB" )
    3. nStart : 검색 시작위치 (옵션 : Default=문자열의 끝 ) ( 예 : 6 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function PosReverse(sOrg, sFind, nStart)
{
	var pos;
	
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;	
	if( IsNull(nStart) )		nStart = sOrg.length-1;

	for( pos = nStart ; pos >= 0 ; pos-- )
	{
		if( sOrg.substr( pos, sFind.length ) == sFind )
			break;
	}
	
	return pos;
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별없이 거꾸로 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "BB" )
    3. nStart : 검색 시작위치 (옵션 : Default=문자열의 끝 ) ( 예 : 6 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 4 )
    - 실패 = -1
 ******************************************************************************/
function PosReverseCase(sOrg, sFind, nStart)
{
	var pos;
	
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;	
	if( IsNull(nStart) )		nStart = sOrg.length-1;

	for( pos = nStart ; pos >= 0 ; pos-- )
	{
		if( sOrg.substr( pos, sFind.length ).toLowerCase() == sFind.toLowerCase() )
			break;
	}
	
	return pos;
}

/*******************************************************************************
 ★ 설명
    시작글자와 끝글자에 해당하는 글자의 사이에 있는 가운데 글자를 
    대소문자를 구별하여 찾는다.
    ( 예 : aaBBbbccdd에서 bb, dd사이의 글자 cc를 찾는다 )
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" )
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )
 ★ return 
    - 성공 = 가운데 글자 ( 예 : "cc" )
    - 실패 = ""
 ******************************************************************************/
function Mid(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = Pos(sOrg, sStart, nStart);
		if( pos_start < 0 )	return "";
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = Pos(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return "";
	}

	return sOrg.substring(pos_start+sStart.length, pos_end);
}

/*******************************************************************************
 ★ 설명
    시작글자와 끝글자에 해당하는 글자의 사이에 있는 가운데 글자를 
    대소문자 구별없이 찾는다.
    ( 예 : aaBBbbccdd에서 bb, dd사이의 글자 bbcc를 찾는다 )
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공 = 가운데 글자 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function MidCase(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = PosCase(sOrg, sStart, nStart);
		if( pos_start < 0 )	return "";
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = PosCase(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return "";
	}

	return sOrg.substring(pos_start+sStart.length, pos_end);
}

/*******************************************************************************
 ★ 설명
    Mid()함수와 동일하나 Return을 Array로 한다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공
      Array[0] = 가운데 글자 ( 예 : "cc" )
      Array[1] = sStart의 위치 ( 예 : 4 )
      Array[2] = sEnd의 위치 ( 예 : 8 )
    - 실패 
      Array[0] = ""
      Array[1] = -1
      Array[2] = -1
 ★ 목적       
    sStart, sEnd의 위치를 알아내려면 다시한번 찾아야 하므로 속도 때문에 만들었다. 
 ******************************************************************************/
function AMid(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	var arr = new Array("",-1,-1);
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = Pos(sOrg, sStart, nStart);
		if( pos_start < 0 )	return arr;
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = Pos(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return arr;
	}
	
	arr[0] = sOrg.substring(pos_start+sStart.length, pos_end);
	arr[1] = pos_start;
	arr[2] = pos_end;
	return arr;
}

/*******************************************************************************
 ★ 설명
    MidCase()함수와 동일하나 Return을 Array로 한다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공
      Array[0] = 가운데 글자 ( 예 : "bbcc" )
      Array[1] = sStart의 위치 ( 예 : 2 )
      Array[2] = sEnd의 위치 ( 예 : 8 )
    - 실패 
      Array[0] = ""
      Array[1] = -1
      Array[2] = -1
 ★ 목적       
    sStart, sEnd의 위치를 알아내려면 다시한번 찾아야 하므로 속도 때문에 만들었다. 
 ******************************************************************************/
function AMidCase(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	var arr = new Array("",-1,-1);
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = PosCase(sOrg, sStart, nStart);
		if( pos_start < 0 )	return arr;
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = PosCase(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return arr;
	}
	
	arr[0] = sOrg.substring(pos_start+sStart.length, pos_end);
	arr[1] = pos_start;
	arr[2] = pos_end;
	return arr;
}

/*******************************************************************************
 ★ 설명
    문자열을 대소문자 구별하여 치환한다
 ★ Parameter 
    1. sOrg   : 원래문자열 (예 : "aaBBbbccBB" )
    2. sRepFrom : 치환할 문자열 ( 예 : "BB" )
    3. sRepTo : 치환될 문자열 ( 예 : "xx" )
 ★ return 
    - 성공 = 치환된 문자열 ( 예 : "aaxxbbccxx" )
    - 실패 = sOrg
 ******************************************************************************/
function Replace( sOrg, sRepFrom, sRepTo )
{
	var pos, nStart=0, sRet="";
	
	if( IsNull(sOrg) )			return "";
	if( IsNull(sRepFrom) )		return sOrg;
	if( IsNull(sRepTo) )		return sOrg;
		
	while(1)
	{
		pos = Pos( sOrg, sRepFrom, nStart );
		if( pos < 0 )
		{
			sRet += sOrg.substr( nStart );
			break;
		}
		else
		{
			sRet += sOrg.substr( nStart, pos - nStart);
			sRet += sRepTo;
			nStart = pos+sRepFrom.length;
		}
	}
	return sRet;
}

/*******************************************************************************
 ★ 설명
    문자열을 대소문자 구별없이 치환한다
 ★ Parameter 
    1. sOrg   : 원래문자열 (예 : "aaBBbbccBB" )
    2. sRepFrom : 치환할 문자열 ( 예 : "BB" )
    3. sRepTo : 치환될 문자열 ( 예 : "xx" )
 ★ return 
    - 성공 = 치환된 문자열 ( 예 : "aaxxxxccxx" )
    - 실패 = sOrg
 ******************************************************************************/
function ReplaceCase( sOrg, sRepFrom, sRepTo )
{
	var pos, nStart=0, sRet="";
	
	if( IsNull(sOrg) )			return "";	
	if( IsNull(sRepFrom) )		return sOrg;
	if( IsNull(sRepTo) )		return sOrg;
		
	while(1)
	{
		pos = PosCase( sOrg, sRepFrom, nStart );
		if( pos < 0 )
		{
			sRet += sOrg.substr( nStart );
			break;
		}
		else
		{
			sRet += sOrg.substr( nStart, pos - nStart);
			sRet += sRepTo;
			nStart = pos+sRepFrom.length;
		}
	}
	return sRet;
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 왼쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "BBbbcc" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ") ( 예 : "bb" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function LTrim(sOrg, sTrim)
{
	var chk, pos;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";

	for( pos = 0 ; pos < sOrg.length ; pos+=sTrim.length )
	{
		if( sOrg.substr( pos, sTrim.length ) != sTrim )
			break;
	}
	
	return sOrg.substr(pos);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별없이 왼쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "BBbbcc" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "bb" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "cc" )
    - 실패 = ""
 ******************************************************************************/
function LTrimCase(sOrg, sTrim)
{
	var pos;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
			
	for( pos = 0 ; pos < sOrg.length ; pos+=sTrim.length )
	{
		if( sOrg.toLowerCase().substr( pos, sTrim.length ) != sTrim.toLowerCase() )
			break;
	}
	
	return sOrg.substr(pos);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 오른쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "CC" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function RTrim(sOrg, sTrim)
{
	var pos, nStart;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
		
	for( pos = sOrg.length-sTrim.length ; pos >= 0 ; pos -= sTrim.length )
	{
		if( sOrg.substr( pos, sTrim.length ) != sTrim )
			break;
	}

	return sOrg.substr(0, pos+sTrim.length);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별없이 오른쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "CC" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bb" )
    - 실패 = ""
 ******************************************************************************/
function RTrimCase(sOrg, sTrim)
{
	var pos, nStart;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
		
	for( pos = sOrg.length-sTrim.length ; pos >= 0 ; pos -= sTrim.length )
	{
		if( sOrg.toLowerCase().substr( pos, sTrim.length ) != sTrim.toLowerCase() )
			break;
	}

	return sOrg.substr(0, pos+sTrim.length);
}

/*******************************************************************************
 ★ 설명
    왼쪽에 문자열 추가.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sPad   : Pad할 문자열(옵션 : Default=" ")( 예 : "aa" )
    3. nCnt   : 반복횟수(옵션 : Default=1) (예 : 2)
 ★ return 
    - 성공 = Pad된 문자열 ( 예 : "aaaabbccCC" )
    - 실패 = ""
 ******************************************************************************/
function LPad(sOrg, sPad, nCnt)
{
	var i, sRet="";

	if( IsNull(sOrg) )		return "";
	if( IsNull(sPad) )		sPad = " ";
	if( IsNull(nCnt) )		nCnt = 1;

	for( i = 0 ; i < nCnt ; i++ )
		sRet += sPad;
	sRet += sOrg;
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    오른쪽에 문자열 추가.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sPad   : Pad할 문자열(옵션 : Default=" ")( 예 : "aa" )
    3. nCnt   : 반복횟수(옵션 : Default=1) (예 : 2)
 ★ return 
    - 성공 = Pad된 문자열 ( 예 : "bbccCCaaaa" )
    - 실패 = ""
 ******************************************************************************/
function RPad(sOrg, sPad, nCnt)
{
	var i, sRet="";

	if( IsNull(sOrg) )		return "";
	if( IsNull(sPad) )		sPad = " ";
	if( IsNull(nCnt) )		nCnt = 1;
	
	sRet += sOrg;
	for( i = 0 ; i < nCnt ; i++ )
		sRet += sPad;
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    문자열의 오른쪽에서 nSize만큼의 문자열을 가져온다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. nSize  : 가져올문자열 길이 ( 예 : 2 )
 ★ return 
    - 성공 = 오른쪽에서 nSize만큼의 문자열 ( 예 : "cc" )
    - 실패 = ""
 ★ 주의사항
    sOrg의 길이가 nSize보다 작은경우는 sOrg가 Return된다.
    ( 예 : sOrg="a", nSize=2 ==> return = "a" )
 ******************************************************************************/
function Right(sOrg, nSize)
{
	if( IsNull(sOrg) || IsNull(nSize) )		return "";
	
	if( sOrg.length < nSize )
		return sOrg;
	else
		return sOrg.substr(sOrg.length-nSize, nSize);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 문자개수 세기
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sCnt   : 개수를 셀 문자열 ( 예 : "BB" )
 ★ return 
    - 성공 = 문자개수 ( 예 : 1 )
    - 실패 = -1
 ******************************************************************************/
function Count(sOrg, sCnt)
{
	var i, sRet="";
	var nCnt = 0;

	if( IsNull(sOrg) || IsNull(sCnt) )		return -1;
	
	for( i = 0 ; i < sOrg.length ; i += sCnt.length )
	{
		if( sOrg.substr(i, sCnt.length) == sCnt )
			nCnt++;
	}
	
	return nCnt;
}

/*******************************************************************************
 ★ 설명
    대소문자 구분없이 문자개수 세기
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sCnt   : 개수를 셀 문자열 ( 예 : "BB" )
 ★ return 
    - 성공 = 문자개수 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function CountCase(sOrg, sCnt)
{
	var i, sRet="";
	var nCnt = 0;

	if( IsNull(sOrg) || IsNull(sCnt) )		return -1;
		
	for( i = 0 ; i < sOrg.length ; i += sCnt.length )
	{
		if( sOrg.toLowerCase().substr(i, sCnt.length) == sCnt.toLowerCase() )
			nCnt++;
	}
		
	return nCnt;
}

/*******************************************************************************
 ★ 설명
    문자 전체 길이를 계산
      - 문자, 숫자, 특수문자 : 1 로 Count	
	  - 그외 한글/한자 : 2 로 count 되어 합산한다.
 ★ Parameter 
    1. sVal   : 입력받은 문자열 ( 예 : "a1\n한韓" )
 ★ return 
    - 성공 = 길이 ( 예 : 7 )
    - 실패 = -1
 ******************************************************************************/
function LenB(sVal)
{
    var len = 0;
   
	if( IsNull(sVal) ) 	return -1;
	
    for (i=0; i<sVal.length; i++)
    {
        if (sVal.charCodeAt(i) > 127)
            len += 2;
        else 
            len += 1;
    }
	
	return len;
}

/*******************************************************************************
 ★ 설명
    전각문자를 반각문자로
    ( 참고 : 전각문자는 "정사각형" 안에 들어가는 문자이고, 반각은 그 정사각형의 반쪽에 들어가는 문자이다.
             전각문자의 폭은, 반각문자의 2배입니다. 
             예를 들어 숫자 "3" 은, 한글 "가"의 절반의 폭만을 가지고 있습니다. 
             그래서 영문과 숫자 등은 반각이고, 한글이나 한자들은 전각문자입니다. 
             다만, 영문과 숫자를 전각으로 표현할 수도 있습니다.
      예 : 전각문자 ==> ※★０＋
           반각문자 ==> 1a )
 ★ Parameter 
    1. sFull   : 전각문자( 예 : "０＋" )
 ★ return 
    - 성공 = 반각문자 ( 예 : "0+" )
    - 실패 = ""
 ******************************************************************************/
function Full2Half(sFull)
{
	var i, c, sHalf = "";
  
	if( IsNull(sFull) )		return "";
	
	for( i=0 ; i < sFull.length ; i++ )
	{
		var c = sFull.charCodeAt(i);

		if (c == 12288) 
			sHalf += unescape("%20"); 
		else if ( (c >= 65281) && (c <= 65374) ) 
			sHalf += unescape("%"+(c-65248).toString(16));
		else 
			sHalf += sFull.charAt(i);
	}
	return  sHalf;
}

/*******************************************************************************
 ★ 설명
    반각문자를 전각문자로
 ★ Parameter 
    1. sHalf   : 반각문자( 예 : "0+" )
 ★ return 
    - 성공 = 전각문자 ( 예 : "０＋" )
    - 실패 = ""
 ******************************************************************************/
function Half2Full(sHalf)
{
    var rTmp = "";
    var iTmp = "";
    var i;
 
 	if( IsNull(sHalf) )		return "";
 	
    for( i = 0 ; i < sHalf.length ; i++ ) 
    {
        //기본 아스키 코드 값을 벗어난 경우(한글)는 전자로 변환할 필요 없음.
        if( (sHalf.charCodeAt(i) >= 32) && (sHalf.charCodeAt(i) <= 126) ) 
        {
			if( sHalf.charCodeAt(i) == 32 ) 
				iTmp = unescape("%u"+(12288).toString(16));
            else 
				iTmp = sHalf.charCodeAt(i) + 65248;
		}
        else 
            iTmp = sHalf.charCodeAt(i);

		if( sHalf.charCodeAt(i) == 32 ) 
			rTmp = rTmp + (iTmp);
		else 
			rTmp = rTmp + String.fromCharCode(iTmp);
    }

    return rTmp;
}


/*******************************************************************************
 ★ 설명
    문자열이 숫자형식에 맞는지 여부 체크
 ★ Parameter 
    1. sNum   : 체크할 문자열숫자 ( 예 : "-1234.56" ) (단, ","가 들어있으면 안 됨)
 ★ return 
    - 숫자형식에 맞는경우 = true
    - 숫자형식에 맞지않는 경우 = false
 ******************************************************************************/
function IsNum(sNum)
{
	var c;
	var point_cnt=0;
	var ret=true;
	
	if( IsNull(sNum) )		return false;
	
	for( i = 0 ; i < sNum.length ; i++ )
	{
		c = sNum.charAt(i);
		if( i == 0 && ( c == "+" || c == "-" ) );
		else if( c >= "0" && c <= "9" );
		else if( c == "." )
		{
			point_cnt++;
			if( point_cnt > 1 )
			{
				ret = false;
				break;
			}
		}
		else
		{
			ret = false;
			break;
		}
	}
	
	return ret;
}

/*******************************************************************************
 ★ 설명
    문자열이 알파벳(a~z, A~Z)만으로 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "aAzZ" ) 
 ★ return 
    - 알파벳만 있는경우 = true
    - 알파벳이 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsAlpha(sVal)
{
	if( IsNull(sVal) )		return false;
	
	if( sVal.search("[^A-Za-z]") >= 0 )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
    문자열이 알파벳(a~z, A~Z), 숫자만으로 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "aAzZ09" ) 
 ★ return 
    - 알파벳, 숫자만 있는경우 = true
    - 알파벳, 숫자가 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsAlNum(sVal)
{
	if( IsNull(sVal) )		return false;

	if( sVal.search("[^A-Za-z0-9]") >= 0 )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
    문자열이 한글로만 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "가나다" ) 
 ★ return 
    - 한글만 있는경우 = true
    - 한글이 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsKor(sVal)
{
	var i;
	
	if( IsNull(sVal) )		return false;
		
	for( i = 0 ; i < sVal.length ; i++ )
	{
		if( !((sVal.charCodeAt(i) > 0x3130 && sVal.charCodeAt(i) < 0x318F) || (sVal.charCodeAt(i) >= 0xAC00 && sVal.charCodeAt(i) <= 0xD7A3)))
			return false;
	}
	
	return true;
}

/*******************************************************************************
 ★ 설명
    숫자에 ","를 집어넣기
 ★ Parameter 
    1. sNum   : 숫자( 예 : -1234567.89 )
 ★ return 
    - 성공 = ","가 들어간 문자열 ( 예 : -1,234,567.89 )
    - 실패 = ""
 ******************************************************************************/
function SetComma(sNum)
{
	var ppos, sDigit, nEnd, nStart=0, sRet="";
	
	if( IsNull(sNum) )	return "";
	
	if( sNum.charAt(0) == "+" || sNum.charAt(0) == "-" )
	{
		sRet += sNum.charAt(0);
		nStart = 1;
	}
	ppos = Pos(sNum, ".", nStart);
	if( ppos < 0 )
		nEnd = sNum.length;
	else
		nEnd = ppos;
	sDigit = sNum.substr(nStart, nEnd-nStart);
	for( pos = 0 ; pos < sDigit.length ; pos ++ )
	{
		if( pos != 0 && (sDigit.length-pos)%3 == 0 )
			sRet += ",";
		sRet += sDigit.charAt(pos);
	}
	sRet += sNum.substr(nEnd);
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    정수인 nStart ~ nEnd의 범위에 있는 숫자에 대하여 random값을 return한다.
 ★ Parameter 
    1. nStart : 시작숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
    2. nEnd   : 끝숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
 ★ return 
    - 성공 = nStart ~ nEnd범위 중 random숫자 (단, nStart, nEnd도 포함됨)
    - 실패 = -1
 ★ 목적
    1. Math.random()이 0 ~ 1사이만 나와서 불편해서 만들었음
    2. Math.random()은 처음에 0.5근처만 나와서 만들었음
 ★ 주의사항
    nStart, nEnd는 정수임에 주의
 ******************************************************************************/
function Rand(nStart, nEnd)
{
	var range_unit, rand, tmp;
	
	if( IsNull(nStart) || IsNull(nEnd) )	return -1;
		
	nStart = Math.floor(nStart);
	nEnd = Math.floor(nEnd);
	if( nStart > nEnd )
	{
		tmp = nStart;
		nStart = nEnd;
		nEnd = tmp;
	}
	range_unit = nEnd-nStart+1;
	
	var dt = new Date();
	rand = (dt.getMilliseconds()+(Math.random()*2000))/3000;

	return Math.floor(rand*range_unit*2)%range_unit+nStart;
}

/*******************************************************************************
 ★ 설명
    Degree를 Radian으로 변환
 ★ parameter 
    1. nDegree : Degree값(예: 180, 90,...)
 ★ return 
    1. 성공 = Radian(예:Math.PI, Math.PI/2,...)
    2. 실패 = NaN
******************************************************************************/ 
function Deg2Rad(nDegree)
{
	return (Math.PI/180)*nDegree;
}

/*******************************************************************************
 ★ 설명
    Radian을 Degree로 변환
 ★ parameter 
    1. nRadian : Radian값(예:Math.PI, Math.PI/2,...)
 ★ return 
    1. 성공 = Degree(예: 180, 90,...)
    2. 실패 = NaN
******************************************************************************/ 
function Rad2Deg(nRadian)
{
	return (180/Math.PI)*nRadian;
}

/*******************************************************************************
 ★ 설명
    화면좌표에서 nBase(X,Y)를 지나는 가로선 대비 n(X,Y)좌표를 Radian각으로 구한다.
 ★ parameter 
    1. nBaseX, nBaseY : 기준 X, Y좌표
    2. nX, nY : X, Y좌표
 ★ return 
    1. 성공 = Radian(예: Math.PI, ...)
    2. 실패 = NaN
******************************************************************************/ 
function GetAngle(nBaseX, nBaseY, nX, nY)
{
	return Math.atan2((nBaseY-nY),(nX-nBaseX));
}

/*******************************************************************************
 ★ 설명
    Array에 있는 값들을 Distinct(중복제거)한다.
 ★ Parameter 
    1. aOrg   : 중복을 제거할 원래 Array ( 예 : (1,1,2,2,3,4,5) )
 ★ return 
    - 성공 = 중복이 제거된 Array ( 예 : (1,2,3,4,5) )
    - 실패 = 빈 Array()
 ******************************************************************************/
function Distinct(aOrg)
{
	var i, j;
	var flag;
	var aDist=new Array();
	var vDist;
	
	if( IsNull(aOrg) )		return aDist;
	
	for( i = 0 ; i < aOrg.length ; i++ )
	{
		vDist = aOrg[i];
		flag = false;
		for( j = 0 ; j < aDist.length ; j++ )
		{
			if( "x"+aDist[j] == "x"+vDist )
			{
				flag = true;
				break;
			}
		}
		if( flag == false )
			aDist[aDist.length] = vDist;			
	}
	
	return aDist;	
}

/*******************************************************************************
 ★ 설명
    sColor(Named Color 혹은 #rgba)를 
    r, g, b, alpha로 된 Array([0] =r, [1] = g, [2] = b, [3] = alpha)로 return한다.
    단, sColor에 alpha가 없으면(Named Color 또는 #rgb인 경우) alpha=#FF로 처리한다.
 ★ parameter 
    1. sColor : Named Color ( 예 : "blue", ... ) 또는 #rgba( 예 : "1234ABCD" )
 ★ return 
    1. 성공 = Array([0] =r, [1] = g, [2] = b, [3] = alpha)
              ( 예 : sColor="blue" ==> [0] = "00", [1] = "00", [2] = "FF", [3] = "FF"
                     sColor="#1234ABCD" ==> [0] = "12", [1] = "34", [2] = "AB", [3] = "CD" )
    2. 실패 = 빈 Array
 ★ 주의사항
    단, sColor에 alpha가 없으면(Named Color 또는 #rgb인 경우) alpha=#FF로 처리한다.
    예를 들어, 
      - sColor="blue ==> [0] = "00", [1] = "00", [2] = "FF", [3] = "FF"
      - sColor="#1234AB" ==> [0] = "12", [1] = "34", [2] = "AB", [3] = "FF" )
******************************************************************************/ 
function AColor(sColor)
{
	var aColor = new Array(4);
	var aNamedColor;

	if( IsNull(sColor) )	return aColor;
	
	sColor = sColor.toString();
	
	// Named Color	처리	
	if( sColor.charAt(0) != "#" )
	{
		var i;
		
		aNamedColor = _NamedColor();
		for( i = 0 ; i < aNamedColor.length ; i++ )
		{
			if( aNamedColor[i][0] == sColor )
			{
				sColor = aNamedColor[i][1];
				break;
			}
		}
		if( i == aNamedColor.length )
			return( new Array() );
	}
	
	// #rgba	
	aColor[0] = sColor.substr(1,2);
	aColor[1] = sColor.substr(3,2);
	aColor[2] = sColor.substr(5,2);
	aColor[3] = sColor.substr(7,2);
	if( aColor[3].length == 0 )
		aColor[3] = "FF";

	return aColor;
}

/*******************************************************************************
 ★ 설명
    MiPlatform의 iif()와 동일
******************************************************************************/ 
function Iif( expr, v_true, v_false )
{
	return expr ? v_true : v_false;
}

/*******************************************************************************
 ★ 설명
    MiPlatform의 decode()와 동일
******************************************************************************/ 
function Decode( )
{
	var i, fn;
	fn = Decode;
	for( i = 1 ; i < fn.arguments.length ; i+=2 )
	{
		if( fn.arguments[0] == fn.arguments[i] )
			return fn.arguments[i+1];
	}
	return fn.arguments[i-2];
}
////////////////////////////////////////////////////////////////////////////////
// String & Number Start
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// File Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    File Path 문자열(예 : C:\a\b\filename.ext)에서 File명(예 : filename)을 추출
 ★ Parameter 
    1. sPath   : File Path 문자열 (예 : "C:\a\b\filename.ext")
    2. bExt    : extend를 return되는 File명에 포함시킬지 여부 ( 옵션 : Default=false )
                 - true : extend를 File명에 포함시킴
                 - false : extend를 File명에 포함시키지 않음
 ★ return 
    - 성공 =
		- bExt = true인 경우 ==> sPath에서 File명(예 : "filename.ext")
		- bExt = false인 경우 ==> sPath에서 File명(예 : "filename")
	- 실패 = ""
 ******************************************************************************/
function GetFileName( sPath, bExt )
{
	var start_pos, end_pos, tmp_pos, filename;

	if( IsNull(sPath) )		return "";
	if( IsNull(bExt) )
		bExt = false;
	
	start_pos = Math.max(PosReverse( sPath, "\\" ), 
						PosReverse( sPath, "/" ));
    tmp_pos = PosReverse( sPath, "::");
	if( tmp_pos > 0 ) tmp_pos++;
	start_pos = Math.max( start_pos, tmp_pos );
	if( bExt == false )
	{
		end_pos = PosReverse( sPath, "." );
		if( end_pos < 0 )
			end_pos = sPath.length;
		filename = sPath.substr( start_pos+1, end_pos-start_pos-1 );
	}
	else
	{
		filename = sPath.substr( start_pos+1 );
	}
		
	return filename;
}

/*******************************************************************************
 ★ 설명
    File Path 문자열(예 : C:\a\b\filename.ext)에서 확장자(예 : ext)을 추출
 ★ Parameter 
    1. sPath   : File Path 문자열 (예 : "C:\a\b\filename.ext")
 ★ return 
    - 성공 = sPath에서 확장자(예 : "ext") (단, "."이 없으면 "" return됨)
    - 실패 = ""
 ******************************************************************************/
function GetFileExt( sPath )
{
	var pos;

	if( IsNull( sPath ) )	return "";
	
	pos = PosReverse( sPath, "." );
	if( pos < 0 )
		return "";
	else
		return sPath.substr( pos+1 );
}

/*******************************************************************************
 ★ 설명
    sPath 문자열(예 : C:\a\b\filename.ext)에서 Path(예 : C:\a\b\)를 추출
 ★ Parameter 
    1. sPath   : Path 문자열 (예 : "C:\a\b\filename.ext")
 ★ return 
    - 성공 = sPath에서 Path(예 : "C:\a\b\")
    - 실패 = ""
 ******************************************************************************/
function GetFilePath( sPath )
{
	var filename;
	
	if( IsNull(sPath) )		return "";
	
	filename = GetFileName( sPath, true );
	if( filename == null )		return null;
	
	return sPath.substr(0, sPath.length - filename.length);
}

/*******************************************************************************
 ★ 설명
    화면내에서 자기 자신화면이 속한 Service ID를 얻어온다.
 ★ Parameter 
    없음
 ★ return 
    - 성공 = 자기 자신화면이 속한 Service ID
    - 실패 = ""
 ******************************************************************************/
 /************ 빼버리기로 했다.
function GetThisServiceID()
{
	var i, service_id, service_path;
	var this_url, this_path, end_pos, start_pos, service_name;
	
	this_url = this.getOwnerFrame().formurl;
	this_url = Replace( this_url, "\\", "/" );

	end_pos = PosReverse( this_url, "/");
	if( end_pos < 0 )
		return "";
	start_pos = PosReverse( this_url, "/", end_pos-1);
	if( start_pos < 0 )
		return "";
	if( (end_pos - start_pos) <= 1 )
		return "";

	service_name = this_url.substr(start_pos, end_pos-start_pos+1);
	service_id = null;
	for( i = 0 ; i < application.services.length ; i++ )
	{
		service_path = Replace(application.services[i].url, "\\", "/");
		if( Right(service_path,1) != "/" )
			service_path += "/";
		
		if( Pos(service_path, service_name) >= 0 )
		{
			service_id = application.services[i].prefixid;
			break;
		}
	}
	
	return service_id;
}
*********************/

/*******************************************************************************
 ★ 설명
    화면내에서 자기 자신화면의 Url을 얻어온다.
 ★ Parameter 
    없음
 ★ return 
    - 성공 = 자기 자신화면의 Url ( 절대경로 또는 Service::a.xfdl 형태로 return됨 )
    - 실패 = ""
 ******************************************************************************/
function GetThisUrl()
{
	var this_url, parent_type;
	
	// Division, Tab, PopupDiv인 경우에는 따로 처리해야 함
	parent_type = GetObjType(parent);
	if( parent_type == "Div" || parent_type == "PopupDiv" || parent_type == "TabPage" )
		this_url = parent.url;
	else
		this_url = this.getOwnerFrame().formurl;
		
	return this_url;
}

/*******************************************************************************
 ★ 설명
    현재 실행되고 있는 Project의 Root Full Path를 얻어온다.
 ★ Parameter 
    없음
 ★ return 
    - 성공 = 현재 실행되고 있는 Project의 Root Full Path
    - 실패 = ""
 ★ 참고사항
    현재 실행되고 있는 ADL Path는 application.xadl을 통해 얻을 수 있다.
 ★ 목적
    Tool에서 system.execXPlatform을 하면 Project경로를 알수 없어 실행이 힘들기
    때문에 만들었다.
 ★ BUG
    모든 화면 Service는 Project내의 바로 한단계 아래의 Sub Directory이고
    ADL은 Project Directory에 있다는 전제하에 만들어 졌다.
    즉, Project=C:\A\, ADL=C:\A\ADL.xadl, Service=C:\A\Service\라는 가정하에
    만들어졌다.
 ******************************************************************************/
function GetProjectPath()
{
	var cur_xadl, filename, project_path;
	
	cur_xadl = application.xadl;
	if( IsNull(cur_xadl) )	return "";

	filename = GetFileName(cur_xadl, true);
	if( IsNull(filename) )	return "";

	// QuickView로 돌린 경우
	if( filename == "empty_adl.xadl" )
	{
		var this_url, pos;
		
		this_url = Replace( childframe.formurl, "\\", "/" );
		pos = PosReverse( this_url, "/");
		if( pos < 0 )
			return "";
		pos = PosReverse( this_url, "/", pos-1);
		if( pos < 0 )
			return "";

		project_path = childframe.formurl.substr(0, pos+1);
	}
	// Launch Project로 돌린 경우
	else
	{
		var trim_path;
		project_path = GetFilePath(application.xadl);
		trim_path = LTrim(project_path, "file://");
		if( trim_path != project_path )
			project_path = Replace( trim_path, "/", "\\" );
	}

	return project_path;
}

/*******************************************************************************
 ★ 설명
     ADL을 주고 XPlatform실행하는 함수
 ★ parameter 
    1. sADL : ADL 
		      1) Full Path지정한 경우 (예 : C:\\Project\\ADL.xadl")
		         Full Path에 해당하는 ADL실행 
              2) ADL명만(확장자제외) 지정한 경우 ( 예 : "ADL" )
                 Project Path내의 ADL실행
              ※ 단, 경로에 대한 유효성 여부는 검사하지 않음
    2. sKey : XPlatform실행시 Key
              (옵션 : Default = ADL명(단, 확장자제외))
 ★ return 
    - 성공 = true 
    - 실패 = false
 ★ 주의사항
    XPLatform실행시 Argument를 전달할 방법은 못 찾겠다.
 ★ 목적    
    PC에서 Tool로 작업시 Project Path를 모를 경우 XPlatform실행이 어려워서 만들었음 
 ******************************************************************************/
function RunXP(sADL, sKey)
{
	var adl_name;
	var project_path;
	var oChildFrame_SDI;
	
	if( IsNull(sADL) )		return false;
	
	adl_name = GetFileName(sADL);
	if( IsNull(sKey) )		sKey = adl_name;

	// FullPath로 지정한 경우
	if( adl_name != sADL )
		system.execXPlatform(" -X \"" + sADL + "\" -K " + sKey);	
	// ADL명만 지정한 경우
	else
	{
		project_path = GetProjectPath();
		if( IsNull(project_path) )
			return false;
		else
			system.execXPlatform(" -X \"" + project_path + sADL + ".xadl" + "\" -K " + sKey);	
	}
		
	return true;
}
////////////////////////////////////////////////////////////////////////////////
// File End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Date Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    윤년여부 확인
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - sDate가 윤년인 경우 = true
    - sDate가 윤년이 아닌 경우 = false
    - sDate가 입력되지 않은 경우 = false
******************************************************************************/  
function IsLeapYear(sDate)
{
    var ret;
    var nY;
    
    if( IsNull(sDate) )		return false;
    
    nY = parseInt(sDate.substring(0,4), 10);

    if ((nY % 4) == 0) 
    {
        if ((nY % 100) != 0 || (nY % 400) == 0) 
            ret = true;
        else 
            ret = false;
    } 
    else 
        ret = false;
  
    return ret;
}

/**********************************************************************************
 ★ 설명
    해당월의 마지막 날짜를 숫자로 구하기 
 ★ parameter 
    1. sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = 마지막 날짜 숫자값 ( 예 : 30 )
    - 실패 = -1
**********************************************************************************/
function LastDateNum(sDate)
{
    var nMonth, nLastDate;

	if( IsNull(sDate) )		return -1;
	
	nMonth = parseInt(sDate.substr(4,2), 10);
    if( nMonth == 1 || nMonth == 3 || nMonth == 5 || nMonth == 7  || nMonth == 8 || nMonth == 10 || nMonth == 12 )
		nLastDate = 31;
    else if( nMonth == 2 )  
    {
        if( IsLeapYear(sDate) == true )
			nLastDate = 29;
        else
			nLastDate = 28;
    } 
    else 
		nLastDate = 30;
		
	return nLastDate;
}

/**********************************************************************************
 ★ 설명
    해당월의 마지막 날짜를 yyyyMMdd형태로 구하기 
 ★ parameter 
    1. sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = yyyyMMdd형태의 마지막 날짜 ( 예 : "20121130" )
    - 실패 = ""
**********************************************************************************/
function LastDate(sDate)
{
	if( IsNull(sDate) )		return "";
	
	var nLastDate = LastDateNum(sDate);
	
	return sDate.substr(0,6) + nLastDate.toString();
}

/*******************************************************************************
 ★ 설명
    날짜 형식이 맞는지 확인
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 날짜형식이 맞는 경우 = true
    - 날짜형식이 맞지 않는 경우 = false
    - sDate가 입력되지 않은 경우 = false
******************************************************************************/  
function IsDate(sDate)
{	
	if( IsNull(sDate) )		return false;
	
    if( sDate.length != 8 )
        return false;
    
    if( IsNum(sDate) != true )
        return false;
    
	var nMonth  = parseInt(sDate.substring(4,6), 10);
	var nDate  = parseInt(sDate.substring(6,8), 10);
    
    if( nMonth < 1 || nMonth > 12 ) 
        return false;
        
    if( nDate < 1 || nDate > LastDateNum(sDate) )
        return false;
    
    return true;
}

/**********************************************************************************
 ★ 설명
    숫자로 된 년, 월, 일을 yyyyMMdd형의 문자열 날짜로 만든다.
 ★ parameter 
    1. nYear  : 년도 ( 예 : 2012 )
    2. nMonth : 월 ( 예 : 11 )
    3. nDate   : 일 ( 예 : 22 )
 ★ return 
    - 성공 = yyyyMMdd형태의 날짜 ( 예 : "20121122" )
    - 실패 = ""
 ★ 주의사항     
    년, 월, 일의 값이 범위에 맞지 않는 값을 입력하면 그에 적합한 날짜로 변경해준다.
    (예 : nYear = 2012, nMonth = 13, nDate = 32 ==> return = "20130201"
          nYear = 2012, nMonth = 1, nDate = -1 ==> return = "20111230")
**********************************************************************************/
function MakeDate(nYear, nMonth, nDate)
{
	if( IsNull(nYear) || IsNull(nMonth) || IsNull(nDate) )	return "";
	
    var objDate = new Date(nYear, nMonth-1, nDate);

	var sYear   = objDate.getFullYear().toString();
	var sMonth  = Right("0" + (objDate.getMonth() + 1), 2);
	var sDate   = Right("0" + objDate.getDate(), 2);

	return sYear + sMonth + sDate;
}


/**********************************************************************************
 ★ 설명
    입력된 날자에 nOffset 으로 지정된 만큼의 일을 증감한다.
 ★ parameter 
    1. sDate : 날짜 ( 예 : "20121122" )
    2. nOffset : 일 증감값 ( 예 : 10 또는 -10 )
 ★ return 
    - 성공 = yyyyMMdd형태의 증감된 날짜 ( 예 : "20121202" 또는 "20121112" )
    - 실패 = ""
**********************************************************************************/
function AddDate(sDate, nOffset)
{
	if( IsNull(sDate) || IsNull(nOffset) )	return "";
	
    var nYear = parseInt(sDate.substr(0, 4));
    var nMonth = parseInt(sDate.substr(4, 2));
    var nDate = parseInt(sDate.substr(6, 2)) + nOffset;

    return MakeDate(nYear, nMonth, nDate);
}

/**********************************************************************************
 ★ 설명
    입력된 날자에 nOffset 으로 지정된 만큼의 월을 증감한다.
 ★ parameter 
    1. sDate : 날짜 ( 예 : "20121122" )
    2. nOffset : 월 증감값 ( 예 : 1 또는 -1 )
 ★ return 
    - 성공 = yyyyMMdd형태의 증감된 날짜 ( 예 : "20121202" 또는 "20121022" )
    - 실패 = ""
 ★ 주의사항    
    단, 증감된 날짜가 그달의 마지막날짜월보다 큰 경우는 드달의 마지막 날짜를 return한다.
    예를 들어, sDate="20120531", nOffset=-1일 경우 return="20120430" 이 된다.
**********************************************************************************/
function AddMonth(sDate, nOffset)
{
	if( IsNull(sDate) || IsNull(nOffset) )		return "";
	
    var nYear = parseInt(sDate.substr(0, 4));
    var nMonth = parseInt(sDate.substr(4, 2))+nOffset;
    var nDate = parseInt(sDate.substr(6, 2));
	var nLastDate, sRet;

	sRet = MakeDate(nYear, nMonth, 1);	
    nLastDate = LastDateNum(sRet);
    sRet = sRet.substr(0,6);
    if( nDate > nLastDate )
		sRet += nLastDate.toString();
	else
		sRet += nDate.toString();
		
	return sRet;
}

/*******************************************************************************
 ★ 설명
    해당 PC의 오늘 날짜를 가져온다.
 ★ parameter 
 ★ return 
    - 성공 = yyyyMMdd형태의 오늘 날짜 ( 예 : "20121122" )
    - 실패 = 없음
******************************************************************************/ 
function Today()
{
	var sToday = "";
	var objDate = new Date();
	var sToday  = objDate.getFullYear().toString();
	sToday += Right("0" + (objDate.getMonth() + 1), 2);
	sToday += Right("0" + objDate.getDate(), 2);

	return sToday;
}	

/*******************************************************************************
 ★ 설명
    해당 PC의 오늘 날짜 + 시간을 가져온다.
 ★ parameter 
 ★ return 
    - 성공 = yyyyMMddhhmiss형태의 오늘 날짜 ( 예 : "20121122223010" )
    - 실패 = 없음
******************************************************************************/ 
function TodayTime()
{
	var strToday = "";
	var objDate = new Date();
	var sToday  = objDate.getFullYear().toString();
	sToday += Right("0" + (objDate.getMonth() + 1), 2);
	sToday += Right("0" + objDate.getDate(), 2);
	sToday += Right("0" + objDate.getHours(), 2);
	sToday += Right("0" + objDate.getMinutes(), 2);
	sToday += Right("0" + objDate.getSeconds(), 2);
	//strToday += objDate.getMilliseconds();
	return sToday;
}	

/*******************************************************************************
 ★ 설명
    두 일자간의 차이 일수 계산
 ★ parameter 
    1. sStartDate : yyyyMMdd형태의 From 일자 ( 예 : "20121122" )
    2. sEndDate   : yyyyMMdd형태의 To 일자 ( 예 : "20121202" )
 ★ return 
    - 성공 = 숫자 형태의 차이일수  ( 예 : 10 ) 
             단, sEndDate < sStartDate이면 음수가 return된다. 
    - 실패 = NaN
 ******************************************************************************/
function DiffDate(sStartDate, sEndDate)
{
	if( IsNull(sStartDate) || IsNull(sEndDate) )		return NaN;
	
    var vFromDate = new Date(parseInt(sEndDate.substring(0,4),  10), parseInt(sEndDate.substring(4,6)-1,  10), parseInt(sEndDate.substring(6,8), 10));
    var vToDate = new Date(parseInt(sStartDate.substring(0,4),  10), parseInt(sStartDate.substring(4,6)-1,  10), parseInt(sStartDate.substring(6,8), 10));
    
    return parseInt((vFromDate - vToDate)/(1000*60*60*24));
}

/*******************************************************************************
 ★ 설명
    두 월간의 차이 월수 계산 
 ★ parameter 
    1. sStartDate : yyyyMMdd형태의 From 일자 ( 예 : "20121122" )
    2. sEndDate   : yyyyMMdd형태의 To 일자 ( 예 : "20131202" )
 ★ return 
    - 성공 = 숫자 형태의 차이월수  ( 예 : 10 )
             단, sEndDate < sStartDate이면 음수가 return된다. 
    - 실패 = NaN
 ★ 주의사항     
    단, sStartDate, sEndDate의 일은 포함하지 않고 계산된다.
**********************************************************************************/
function DiffMonth(sStartDate, sEndDate)
{
	var nStartMon, nEndMon;
	
	if( IsNull(sStartDate) || IsNull(sEndDate) )	return NaN;
	
	nStartMon = parseInt(sStartDate.substr(0,4), 10)*12 + parseInt(sStartDate.substr(4,2), 10);
	nEndMon = parseInt(sEndDate.substr(0,4), 10)*12 + parseInt(sEndDate.substr(4,2), 10);
	
	return (nEndMon - nStartMon);
}

/*******************************************************************************
 ★ 설명
    Date기본 Format( = yyyyMMdd[hhmiss])를 
    XP Date기본 Format( = yyyy-MM-dd[ hh:mi:ss] ) 으로 바꾸어줌
 ★ parameter 
    1. sDate : yyyyMMdd[hhmiss]형태의 일자 ( 예 : "20121122" 또는 "20121122010203")
 ★ return 
    - 성공 = XP Date기본 Format( 예 : "2012-11-22" 또는 "2012-11-22 01:02:03")
    - 실패 = ""
 ★ 주의사항
    sDate는 yyyyMMdd 또는 yyyyMMddhhmiss 형태만 처리된다.
**********************************************************************************/
function Date2XP(sDate)
{
	var ret;
	
	if( IsNull(sDate) )		return "";
	
	if( sDate.length != 8 && sDate.length != 14 )
		return "";
	ret = sDate.substr(0, 4) + "-" + sDate.substr(4, 2)+ "-" + sDate.substr(6, 2);
	if( sDate.length > 8 )
		ret += " " + sDate.substr(8,2) + ":" + sDate.substr(10,2) + ":" + sDate.substr(12,2);
	
	return ret;
}

/*******************************************************************************
 ★ 설명
    양력을 음력으로 변환해주는 함수 (처리가능 기간  1841 - 2043년)
 ★ parameter 
    1. sDate : yyyyMMdd형태의 양력일자 ( 예 : "20121122" )
 ★ return 
    - 성공 = Flag(1 Byte) + (yyyyMMdd형태의 음력일자)
			( Flag : 평달 = "0", 윤달 = "1" )
    - 실패 = "" ( 1841 ~ 2043 범위 오류시 )
 ★ 주의사항
    1. return값이 8자리가 아니고 9자리임에 주의
    2. 속도가 별로 안좋네
    3. 처리가능 기간  1841 - 2043년
**********************************************************************************/
function Solar2Lunar(sDate)
{
	var sMd = "31,0,31,30,31,30,31,31,30,31,30,31";
	var aMd = new Array();

	var aBaseInfo = new Array();
	var aDt = new Array();		// 매년의 음력일수를 저장할 배열 변수
	var td;					// 음력일을 계산하기 위해 양력일과의 차이를 저장할 변수
	var td1;					// 1840년까지의 날수
	var td2;					// 현재까지의 날수
	var mm;					// 임시변수
	var nLy, nLm, nLd;			// 계산된 음력 년, 월, 일을 저장할 변수
	var sLyoon;					// 현재월이 윤달임을 표시

	if( IsNull(sDate) )		return "";
	
	sY = parseInt(sDate.substr(0,4), 10);
	sM = parseInt(sDate.substr(4,2), 10);
	sD = parseInt(sDate.substr(6,2), 10);
	if( sY < 1841 || sY > 2043 )	return "";

	aBaseInfo = _SolarBase();
	aMd = sMd.split(",");
	if( IsLeapYear(sDate) == true )					
		aMd[1] = 29;
	else
		aMd[1] = 28;	
	
	td1 = 672069; 				 // 672069 = 1840 * 365 + 1840/4 - 1840/100 + 1840/400 + 23  //1840년까지 날수
		
	// 1841년부터 작년까지의 날수
	td2 = (sY - 1) * 365 + parseInt((sY - 1)/4) - parseInt((sY - 1)/100) + parseInt((sY - 1)/400);
		
	// 전월까지의 날수를 더함
	for( i = 0 ; i <= sM - 2 ; i++ )
		td2 = td2 + parseInt(aMd[i]);

	// 현재일까지의 날수를 더함
	td2 = td2 + sD;

	// 양력현재일과 음력 1840년까지의 날수의 차이
	td = td2 - td1 + 1;
	
	// 1841년부터 음력날수를 계산
	for( i = 0 ; i <= sY - 1841 ; i++ )
	{
		aDt[i] = 0;
		for( j = 0 ; j <= 11 ; j++ )
		{
			switch( parseInt(aBaseInfo[i*12 + j]) )
			{
				case 1 : mm = 29;
						 break;
				case 2 : mm = 30;
						 break;				
				case 3 : mm = 58;	// 29 + 29
						 break;				
				case 4 : mm = 59;	// 29 + 30
						 break;				
				case 5 : mm = 59;	// 30 + 29
						 break;				
				case 6 : mm = 60;	// 30 + 30
						 break;				
			}
			aDt[i] = aDt[i] + mm;
		}
	}
		
	// 1840년 이후의 년도를 계산 - 현재까지의 일수에서 위에서 계산된 1841년부터의 매년 음력일수를 빼가면수 년도를 계산
	nLy = 0;
	do
	{
		td = td - aDt[nLy];
		nLy = nLy + 1;
	}
	while(td > aDt[nLy]);
	
	nLm = 0;
	sLyoon = "0";			// 현재월이 윤달임을 표시할 변수 - 기본값 평달
	do
	{
		if( parseInt(aBaseInfo[nLy*12 + nLm]) <= 2 )
		{
			mm = parseInt(aBaseInfo[nLy*12 + nLm]) + 28;
			if( td > mm )
			{
				td = td - mm;
				nLm = nLm + 1;
			}
			else
				break;
		}
		else
		{
			switch( parseInt(aBaseInfo[nLy*12 + nLm]) )
			{
				case 3 :
					m1 = 29;
					m2 = 29;
					break;
				case 4 : 
					m1 = 29;
					m2 = 30;
					break;					
				case 5 : 
					m1 = 30;
					m2 = 29;
					break;					
				case 6 : 
					m1 = 30;
					m2 = 30;
					break;					
			}

			if( td > m1 )
			{
				td = td - m1;
				if( td > m2 )
				{
					td = td - m2;
					nLm = nLm + 1;
				}
				else
				{
					sLyoon = "1";
				}
			}
			else
			{
				break;
			}
		}
	}
	while(1);
	
	nLy = nLy + 1841;
	nLm = nLm + 1;
	nLd = td;

	return sLyoon+nLy+Right("0" + nLm, 2)+Right("0" + nLd, 2);
}

/*******************************************************************************
 ★ 설명
    음력을 양력으로 변환해주는 함수 (처리가능 기간  1841 - 2043년)
 ★ parameter 
    1. sDate : Flag(1 Byte)+yyyyMMdd형태의 음력일자 ( 예 : "020121122" )
				( Flag : 평달 = "0", 윤달 = "1" )
 ★ return 
    - 성공 = yyyyMMdd형태의 양력일자
    - 실패 = null 
			  - 1841 ~ 2043 범위 오류의 경우
			  - sDate가 9자리가 아닐경우
			  - sDate의 첫자리 Flag가 "0"도 아니고 "1"도 아닌 경우
 ★ 주의사항
    1. sDate가 8자리가 아니고 9자리임에 주의
    2. 속도가 별로 안좋네
    3. 처리가능 기간  1841 - 2043년    
**********************************************************************************/
function Lunar2Solar(sDate)
{
	var sMd = "31,0,31,30,31,30,31,31,30,31,30,31";
	var aMd = new Array();	
	var aBaseInfo = new Array();	
	
	var nLy, nLm, nLd, sLflag;		// 전해온 음력 인자값을 저장할 년, 월, 일, 윤달여부 임시변수
	var nSy, nSm, nSd;				// 계산된 양력 년, 월, 일을 저장할 변수
	var y1, m1, i, j, y2, y3;	// 임시변수	
	var leap;

	if( IsNull(sDate) )			return "";
	if( sDate.length != 9 )		return "";
	
	sLflag = sDate.substr(0,1);
	nLy = parseInt(sDate.substr(1,4), 10);
	nLm = parseInt(sDate.substr(5,2), 10);
	nLd = parseInt(sDate.substr(7,2), 10);
	if( nLy < 1841 || nLy > 2043 )			return "";
	if( sLflag != "0" && sLflag != "1" )	return "";
		
	aBaseInfo = _SolarBase();
	aMd = sMd.split(",");
	if( IsLeapYear(sDate.substr(1,8)) == true )					
		aMd[1] = 29;
	else
		aMd[1] = 28;	
		
	y1 = nLy - 1841;
	m1 = nLm - 1;
	leap = 0;
	if( parseInt(aBaseInfo[y1*12 + m1]) > 2 )
		leap = IsLeayYear(nLy+"0101");
	
	if( leap == 1 )
	{
		switch( parseInt(aBaseInfo[y1*12 + m1]) )
		{
			case 3 : mm = 29;
					 break;
			case 4 : mm = 30;
					 break;			
			case 5 : mm = 29;
					 break;			
			case 6 : mm = 30;
					 break;
		}
	}
	else
	{
		switch( parseInt(aBaseInfo[y1*12 + m1]) )
		{
			case 1 : mm = 29;
					 break;			
			case 2 : mm = 30;
					 break;			
			case 3 : mm = 29;
					 break;			
			case 4 : mm = 29;
					 break;			
			case 5 : mm = 30;
					 break;			
			case 6 : mm = 30;
					 break;			
		}
	}

	td = 0;
	for( i = 0 ; i <= y1 - 1 ; i++ )
	{
		for( j = 0 ; j <= 11 ; j++ )
		{
			switch( parseInt(aBaseInfo[i*12 + j]) )
			{
				case 1 : td = td + 29;
						 break;
				case 2 : td = td + 30;
						 break;				
				case 3 : td = td + 58;
						 break;				
				case 4 : td = td + 59;
						 break;				
				case 5 : td = td + 59;
						 break;				
				case 6 : td = td + 60;
						 break;				
			}
		}
	}

	for( j = 0 ; j <= m1 - 1 ; j++ )
	{
		switch( parseInt(aBaseInfo[y1*12 + j]) )
		{
			case 1 : td = td + 29;
					 break;			
			case 2 : td = td + 30;
					 break;						
			case 3 : td = td + 58;
					 break;						
			case 4 : td = td + 59;
					 break;						
			case 5 : td = td + 59;
					 break;						
			case 6 : td = td + 60;
					 break;						
		}
	}

	if( leap == 1 )
	{
		switch( parseInt(aBaseInfo[y1*12 + m1]) )
		{
			case 3 : mm = 29;
					 break;						
			case 4 : mm = 29;
					 break;						
			case 5 : mm = 30;
					 break;						
			case 6 : mm = 30;
					 break;						
		}
	}
	
	td = td + nLd + 22;
	
	if( sLflag == "1" )
	{
		switch( parseInt(aBaseInfo[y1*12 + m1]) )
		{
			case 3 : td = td + 29;
					 break;						
			case 4 : td = td + 30;
					 break;						
			case 5 : td = td + 29;
					 break;						
			case 6 : td = td + 30;
					 break;						
		}
	}
	
	y1 = 1840;
	do
	{
		y1 = y1 + 1;
		leap = IsLeapYear(y1+"0101");

		if( leap == 1 )
			y2 = 366;
		else
			y2 = 365;

		if( td <= y2 )
			break;
			
		td = td - y2;
	}
	while(1);

	nSy = y1;
	aMd[1] = y2 - 337;
	m1 = 0;
	do
	{
		m1 = m1 + 1;
		if( td <= parseInt(aMd[m1-1]) )
			break;
		td = td - parseInt(aMd[m1-1]);
	}
	while(1);
	
	nSm = m1;
	nSd = td;
	y3 = nSy;
	td = y3 * 365 + parseInt(y3/4) - parseInt(y3/100) + parseInt(y3/400);
	for( i = 0 ; i <= nSm - 1 ; i++ )
		td = td + parseInt(aMd[i]);

	td = td + nSd;

	return y3 + Right("0" + nSm, 2)+Right("0" + nSd, 2);
}

/*******************************************************************************
 ★ 설명
    요일구하기
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = 요일(0=일요일, ~ , 6=토요일)
    - 실패 = -1
 ★ 목적
    XPlatofrm거는 쓰기가 불편해서 만들었음
******************************************************************************/  
function GetDay(sDate)
{
	if( IsNull(sDate) )		return -1;
	
	var oDate = new Date(Date2XP(sDate));
	return oDate.getDay();	
}

/*******************************************************************************
 ★ 설명
    양력 nYear에 해당하는 년도의 법정 공휴일(양력) List 모두 구하기
 ★ parameter 
    nYear : nYear에 해당하는 년도 ( 예 : 2012 )
 ★ return 
    - 성공 = 공휴일 List Array ==> 각 Array[i]="yyyyMMdd공휴일명" 으로 return된다.
             ( 예 : Array[0] = "20120101신정" )
    - 실패 = 빈 Array
 ★ 목적    
    1. Solar2Lunar()가 너무느려서 만들었음 
******************************************************************************/  
function GetHolidays(nYear)
{
	var nYear;
	var aHoliday = new Array();

	if( IsNull(nYear) )		return aHoliday;
	
	/////// 음력 체크
	// 구정
	aHoliday[0] = Lunar2Solar( "0" + (nYear-1) + "1230" ) + "설날";
	aHoliday[1] = AddDate(aHoliday[0], 1) + "설날";
	aHoliday[2] = AddDate(aHoliday[1], 1) + "설날";
	// 석가탄신일
	aHoliday[3] = Lunar2Solar( "0" + nYear + "0408" ) + "석가탄신일";
	// 추석
	aHoliday[4] = Lunar2Solar( "0" + nYear + "0814" ) + "추석";
	aHoliday[5] = AddDate(aHoliday[4], 1) + "추석";
	aHoliday[6] = AddDate(aHoliday[5], 1) + "추석";	

	/////// 양력 체크
	aHoliday[7] = nYear+"0101" + "신정";
	aHoliday[8] = nYear+"0301" + "삼일절";
	aHoliday[9] = nYear+"0505" + "어린이날";	
	aHoliday[10] = nYear+"0606" + "현충일";		
	aHoliday[11] = nYear+"0815" + "광복절";			
	aHoliday[12] = nYear+"1225" + "성탄절";			
	
	return aHoliday.sort();
}

////////////////////////////////////////////////////////////////////////////////
// Date End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Form & Component Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
     Modal Dialog실행 함수
 ★ parameter 
    _NewChildFrame()참조
 ★ return 
    - 성공 = variant ( Dialog창에서 close()에 의해 Return된 값 )
    - 실패 = ""
 ******************************************************************************/
function Dialog(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var rtn=null;
	var newChild;
	var MyFrame = this.getOwnerFrame();	
	
	newChild = _NewChildFrame(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp);
	rtn = newChild.showModal(sID, MyFrame, sArg);
	this.removeChild(newChild.name);
	newChild.destroy();
	newChild = null;

	if( IsNull(rtn) )	rtn = "";
	
	return rtn;
}

/*******************************************************************************
 ★ 설명
     Modaless Dialog실행 함수
 ★ parameter 
    _NewChildFrame()참조
 ★ return 
    - 성공 = true ( 정상작동여부 )
    - 실패 = false
 ******************************************************************************/
function Open(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var rtn;
	var newChild;
	var MyFrame = this.getOwnerFrame();
		
	newChild = _NewChildFrame(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp);
	
	return newChild.showModeless(sID, MyFrame, sArg);	
}

/*******************************************************************************
 ★ 설명
     Object의 Property를  설정한한다.
 ★ parameter 
    1. sObjName = Object Name ( 예 : Button00, ... )
    2. sPropName = Property Name ( 예 : enable, style.border, ... )
    3. sPropVal - Property Value ( 예 : true, "1 solid blue", ... )
 ★ return 
    - 성공 = 수행된 Property Setting 문자열 ( TEST를 위해 Return함 )
    - 실패 = ""
 ******************************************************************************/
function SetProp(sObjName, sPropName, sPropVal)
{
	if( IsNull(sObjName) || IsNull(sPropName) || IsNull(sPropVal) )		return "";
	
	var sPropExpr = sObjName+"."+sPropName+" = " + sPropVal;
	eval(sPropExpr);
	
	return sPropExpr;
}

/*******************************************************************************
 ★ 설명
     Object의 Property를  가져온다.
 ★ parameter 
    1. sObjName = Object Name ( 예 : Button00, ... )
    2. sPropName = Property Name ( 예 : enable, style.border, ... )
 ★ return 
    - 성공 = Property 값
    - 실패 = eval()과 동일
 ******************************************************************************/
function GetProp(sObjName, sPropName, sPropVal)
{
	var sPropExpr = sObjName+"."+sPropName;
	return eval(sPropExpr);
}

/*******************************************************************************
 ★ 설명
     Object의 type을 문자열로 얻어온다.
 ★ parameter 
    1. oObj : type을 얻어올 Object
			  (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = Object의 type문자열(예 : "MainFrame", "ChildFrame", "Form", "Button",...) 
    - 실패 = ""
 ******************************************************************************/
function GetObjType(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return "";
	
	sType = oObj.toString().valueOf().substr(1,6);
	if( sType.toLowerCase() == "object" )
		return Mid(oObj.toString().valueOf(), " ", "]");

	return "";
}

/*******************************************************************************
 ★ 설명
     모든 Collection이 type을 이용하여 얻어오는 것이 없으므로 type을 이용하여
     Collection을 얻어오는 함수임
     단, type은 Object에 의해 나오는 Value값을 의미한다.
     예를들어, alert(Button0)="[object Button]" 에서 "Button"을 Type이라 한다.
 ★ parameter 
    1. oCollection : Collection Object(예 : this.components, mainframe.all, ...)
    2. sType       : Type문자열 (예 : "ChildFrame", "Button")
					 (옵션: Default="" ==> return은 oCollection이 된다.)
 ★ return 
    - 성공 = Collection List중 sType에 적합한 Object만 Array로 Return한다.
    - 실패 = 
 ******************************************************************************/
function GetObjTypeCollection(oCollection, sType)
{
	var sType, i, arr=new Array(), arr_no=0, sColType;
	
	if( IsNull(oCollection) )		return arr;
	if( IsNull(sType) )			
	{
		arr = oCollection;
		return arr;
	}
	for( i = 0 ; i < oCollection.length ; i++ )
	{
		sColType = GetObjType(oCollection[i]);
		if( IsNull(sColType) )	continue;
		if( sType.toLowerCase() == sColType.toLowerCase() )
		{
			arr[arr_no] = oCollection[i];
			arr_no++;
		}
	}

	return arr;
}

/*******************************************************************************
 ★ 설명
     sObjName이 Popup창(showModaless()에 의해 뜬창)인지 확인한다.
     단, showModal()에 의해 뜬 창은 해당되지 않는다.
 ★ parameter 
    1. sObjName : Popup창 여부를 확인할 Object Name
 ★ return 
    - sObjName이 Popup창인 경우 = true
    - sObjName이 Popup창이 아닌 경우 = false
 ★ 주의사항
    단, showModal()에 의해 뜬 창은 해당되지 않는다. 
 ******************************************************************************/
function IsObjPopup(sPopupName)
{
	if( IsNull(sPopupName) )	return false;
	
	if( IsNull(application.popupframes(sPopupName)) )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
     Object를 생성한다. 만일 Object가 이미 존재하면 존재하는 Object를 return한다.
     (예 : sObjType="Button", sObjName="Button00"이면 
           Button00 Object를 생성하여 oParent에 포함시킨 후 Return한다.)
 ★ parameter 
    1. sObjName : 생성할 Object Name ( 예 : "Button00" )
    2. sObjType : 생성할 Object Type ( 예 : "Button", "Static", ... )
    3. oParent  : 포함시킬 부모 Object(옵션 : Default=this) (예 : this, childframe, ... )
    4. bShow    : 화면에 보여질지 여부 (옵션 : Default=true)
 ★ return 
    - 성공 = 생성된 Object 또는 이미 존재하면 해당 Object
    - 실패 = null
 ★ 주의사항
    - Component생성만 할것, 다른 Object는 Test안해봐서 신뢰할 수 없음
 ******************************************************************************/
function NewObj(sObjName, sObjType, oParent, bShow)
{
	var sFstr, oRet, aObjExist;

	if( IsNull(sObjName) )	return null;
	if( IsNull(sObjType) ) 	return null;
	
	if( IsNull(oParent) )	oParent = this;	
	if( IsNull(bShow) ) 	bShow = true;
	
	aObjExist = oParent.all(sObjName);
	if( aObjExist != null )
		return aObjExist;
	
	sFstr = "new " + sObjType + "(\"" + sObjName + "\")";
	oRet = eval(sFstr);
	if( IsNull(oRet) )
		return null;
		
	if( oParent.addChild(sObjName, oRet) == -1 )
		return null;

	if( bShow == true )
		oRet.show();
	
	return oRet;
}

/*******************************************************************************
 ★ 설명
     Object를 생성한다. 만일 Object가 이미 존재하면 존재하는 Object를 return한다.
     (예 : sObjType="Button", sObjName="Button00"이면 
           Button00 Object를 생성하여 oParent에 포함시킨 후 Return한다.)
 ★ parameter 
    1. sObjName : 생성할 Object Name ( 예 : "Button00" )
    2. sObjType : 생성할 Object Type ( 예 : "Button", "Static", ... )
    3. oParent  : 포함시킬 부모 Object(옵션 : Default=this) (예 : this, childframe, ... )
    4. bShow    : 화면에 보여질지 여부 (옵션 : Default=true)
 ★ return 
    - 성공 = 생성된 Object 또는 이미 존재하면 해당 Object
    - 실패 = null
 ★ 주의사항
    - Component파괴만 할것, 다른 Object는 Test안해봐서 신뢰할 수 없음
 ******************************************************************************/
function DelObj(sObjName, oParent)
{
	var oObj;
	
	if( IsNull(sObjName) )	return false;
	
	if( IsNull(oParent) )	
		oParent = this;
	
	oObj = oParent.all(sObjName);	
	if( oObj == null )	return true;
	
	oParent.removeChild(sObjName); 	
	
	oObj.destroy();
	oObj = null;

	return true;
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 좌표계가 Screen좌표계인지를 체크한다.
 ★ parameter 
    1. oObj : 체크할 Object(예 : mainframe, this.getOwnerFrame(), this, button,...)
  ★ return 
    - oObj가 Screenr기준 좌표계인 경우 = true
    - oObj가 Screenr기준 좌표계가 아닌경우 = false
    - oObj가 null인 경우 = false    
 ******************************************************************************/
function IsObjScreenPos(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return false;
	
	sType = GetObjType(oObj);
	if( IsNull(sType) ) 	return false;

	if( sType.toLowerCase() == "mainframe" )
		return true;
	if( sType.toLowerCase() == "childframe" )
	{
		if( IsObjPopup(oObj.name) == true )
			return true;
	}
		
	return false;
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 Object가 Position을 갖지 않는 Object인지 판단한다.
    즉, oObj가 invisible Object인지 판단한다.
 ★ parameter 
    1. oObj : 체크할 Object(예 : application, mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - oObj가 position property가 없는 경우 = true
    - oObj가 position property가 있는 경우 = false
    - oObj가 null인 경우 = false
 ******************************************************************************/
function IsObjNoPos(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return false;
	
	sType = GetObjType(oObj);
	if( IsNull(sType) ) 	return false;

	if( IsNull(oObj.position) )
		return true;
		
	return false;
}

/*******************************************************************************
 ★ 설명
     system의 cursorx, cursory를 해당 Object의 영역좌표에 맞는 값으로 변경한다.
 ★ parameter 
    1. oObj : Object 
       (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = oObj좌표계에 해당하는 Cursor position 문자열 ( 예 : "20 20" ) 
    - 실패 = ""
 ★ 주의사항    
    단, event에서 얻어지는 cursor좌표는 아니다. 
 ******************************************************************************/
function GetObjCursorPos(oObj)
{
	var sObjPos;
	var cursorx, cursory;
	var sCursorPos;

	if( IsNull(oObj) ) 	return "";
	if( IsObjNoPos(oObj) ) 	return "";
	
	cursorx = system.cursorx;
	cursory = system.cursory;
	
	if( IsObjScreenPos(oObj) == true )
		sCursorPos = cursorx + " " + cursory;
	else
		sCursorPos = (system.screenToClientX(oObj, cursorx)+oObj.position.left) + " " +	(system.screenToClientY(oObj, cursory)+oObj.position.top);		

	return sCursorPos;
}

/*******************************************************************************
 ★ 설명
    Position문자열을 Rect Object로 바꾼다.
 ★ parameter 
    1. sPos : Position 문자열 (예 : "10 10 50 50" 또는 "10 10")
 ★ return 
    1. 성공 = Rect Object
              (※ 단,  sPos = "10 10" ==> 2개인 경우
                  Rect.right = Rect.left, Rect.bottom = Rect.top,
                  Rect.width = 0, Rect.height = 0)
    2. 실패 = null
 ★ 주의사항
    1. Rect Object는 좌표를 처리하는 XPlatform 내부 Object로서 메뉴얼에는 존재치 않는다.
       Rect Object의 멤버는 left, top, right, bottom, width, height가 있다.
       (예 : rect가 Rect Object라면 rect.left, rect.top으로 사용하면 된다.)
    2. Rect Object내에서의 좌표 처리 방법 ( 
       1) right ==> width순으로 처리하면 right는 재계산된다.
          width ==> right순으로 처리하면 right는 재계산 되지 않는다.
       2) width처리를 하지 않고 right만 처리하면 width는 자동계산 된다.
          right처리를 하지 않고 width만 처리하면 right는 자동계산 된다.
       3) 위 1), 2)는 left를 먼저 지정했을 경우에 한하여 처리된다.
          또한, top, bottom에 대해서도 동일하게 처리된다.
******************************************************************************/ 
function Str2Rect(sPos)
{
	var oRect = new Rect();
	var i;
	var aPos, no;
	
	if( IsNull(sPos) )	return null;
	
	aPos = sPos.toString().split(" ");;
	if( aPos.length == 0 )
		return null;
		
	no = 0;
	for( i = 0 ; i < aPos.length ; i++ )
	{
		if( IsNum(aPos[i]) == true )
		{
			if( no == 0 )		oRect.left = Math.round(parseFloat(aPos[i]),1);
			if( no == 1 )		oRect.top = Math.round(parseFloat(aPos[i]),1);
			if( no == 2 )		oRect.right = Math.round(parseFloat(aPos[i]),1);
			if( no == 3 )		oRect.bottom = Math.round(parseFloat(aPos[i]),1);
			if( no == 4 )		oRect.width = Math.round(parseFloat(aPos[i]),1);
			if( no == 5 )		oRect.height = Math.round(parseFloat(aPos[i]),1);
			no++;
		}
	}

	if( no != 2 && no != 4 && no != 6 )
		return null;
		
	if( no == 2 )
	{
		oRect.right = oRect.left;
		oRect.bottom = oRect.top;
		oRect.width = 0;
		oRect.height = 0;
	}
	
	return oRect;
}

/*******************************************************************************
 ★ 설명
    Rect Object를 Position문자열로 바꾼다.
 ★ parameter 
    1. oRect : Rect Object(예 : Rect.left = 10, ... )
 ★ return 
    1. 성공 = Position문자열 ( 예 : "10 20 30 40" )
              (※ 단,  
                  Rect.right = Rect.left, Rect.right = Rect.left, 
                  Rect.width = 0, Rect.height = 0 인경우는
                  return = "10 10")
    2. 실패 = ""
 *****************************************************************************/ 
function Rect2Str(oRect)
{
	if( IsNull(oRect) )		return "";
	
	if( IsPoint(oRect) == true )
		return oRect.left + " " + oRect.top;
	else
		return oRect.left + " " + oRect.top + " " + oRect.right + " " + oRect.bottom;
}

/*******************************************************************************
 ★ 설명
    Rect Object의 내용이 Point(left, top만  유효한 경우)인지 판단한다.
 ★ parameter 
    1. oRect : Rect Object(예 : Rect.left = 10, ... )
 ★ return 
    1. 성공 = true (Point인 경우)
    2. 실패 = false ( oRect가 null이거나 Point가 아닌 경우)
 *****************************************************************************/ 
function IsPoint(oRect)
{
	if( IsNull(oRect) )		return false;
	
	if( (oRect.left == oRect.right && oRect.top == oRect.bottom) ||
		(oRect.width == 0 && oRect.height == 0 ) ||
		( (oRect.left != 0 && oRect.right == 0) && (oRect.top != 0 && oRect.bottom == 0) ) )
		return true;
	else
		return false;
}

/*******************************************************************************
 ★ 설명
     sAreaPos의 Center위치에 맞는 sObjPos의 position을 구한다.
 ★ parameter 
    1. sAreaPos : 영역에 해당하는 Position 문자열
				(예 : "10 10 50 50", this.position,...)
    2. sObjPos  : Center에 위치할 대상 Object의 Position
                  (옵션 : Default="" ==> Object의 Width=0, Height=0인 경우에 해당함)
				(예 : "", "10 10 30 30", this.position,...)
 ★ return 
    - 성공 = sAreaPos의 좌표계에 해당하는 Center position 문자열 
              ( 예 : sObjPos=""인 경우 ==> "30 30", 
                     sObjPos="10 10 20 20"인 경우 ==> "20 20 40 40" )
    - 실패 = ""                     
 ******************************************************************************/
function GetCenterPos(sAreaPos, sObjPos)
{
	var vAreaPos;
	var vObjPos  = new Rect();
	var vCenterPos = new Rect();

	if( IsNull(sAreaPos) )	return "";
	vAreaPos = Str2Rect(sAreaPos);
	if( IsNull(vAreaPos) )		return "";

	if( IsNull(sObjPos) )	
	{
		vObjPos.left = vObjPos.right = 0;
		vObjPos.top = vObjPos.bottom = 0;
		vObjPos.width = 0;
		vObjPos.height = 0;
	}
	else
	{
		vObjPos = Str2Rect(sObjPos);
		if( IsNull(vObjPos) )		return "";
	}

	if( IsPoint(vObjPos) == true )
	{
		vCenterPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1);
		vCenterPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1);
	}
	else
	{
		vCenterPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1) - Math.round(vObjPos.width/2,1);
		vCenterPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1) - Math.round(vObjPos.height/2,1);
		vCenterPos.right = vCenterPos.left + vObjPos.width;
		vCenterPos.bottom = vCenterPos.top + vObjPos.height;
	}

	return Rect2Str(vCenterPos);
}

/*******************************************************************************
 ★ 설명
     nLeft, nTop좌표로
     sPosition의 Width에 대해 n Offset Width만큼, 
     sPosition의 Height에 대해 n Offset Height만큼 
     이동한 좌표 Position문자열을 획득한다.
 ★ parameter 
    1. sPosition     : position 문자열 (예 : "absolute 10 10 20 20" = object.position ) 
                       단, "absolute"는 생략 가능하다.
    2. nLeft         : 이동할 Left 값 ( 예 : 10 또는 -10 )
    3. nTop          : 이동할 Top 값 ( 예 : 10 또는 -10 )
    4. nOffsetWidth  : 이동할 Offset Width값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
    5. nOffsetHeight : 이동할 Offset Height값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
 ★ return 
    - 성공 = 이동될 Position문자열 ( 예 : "absolute 20 20 30 30" 또는 "absolute 0 0 10 10" )
              단, sPosition이 2개만 지정된 경우 offsetWidth, nOffsetHeight에 어떤값을 지정하면
              이 경우는 Widht=0, Height=0와 동일하므로 4개로 바꾸어 Return한다.
              ( 예 : GetMovePos("10 10", 20, 20) = "20 20 20 20" )
    - 실패 = "" 
 ★ 목적
    XPlatform은 Width, Height가 아닌 Right, Bottom을 적용하기 때문에 헷갈리는 면이 있다.
    또한, object를 이동시키는 함수는 있지만 이동될 좌표만 구하는 함수가 없기 때문에
    이 함수를 만들었다.
 ******************************************************************************/
function GetMovePos(sPosition, nLeft, nTop, nOffsetWidth, nOffsetHeight)
{
	var sType;
	var vPosition;
	var vRetPosition = new Rect();

	if( IsNull(sPosition) || IsNull(nLeft) || IsNull(nTop) )	return "";
	
	if( IsNull(nOffsetWidth) )			
		nOffsetWidth = 0;
	if( IsNull(nOffsetHeight) )			
		nOffsetHeight = 0;

	vPosition = Str2Rect(sPosition);
	if( IsNull(vPosition) )		return "";

	vRetPosition.left = nLeft;
	vRetPosition.top = nTop;
	if( IsPoint(vPosition) == true ) 
	{
		if( nOffsetWidth == 0 && nOffsetHeight == 0 ) 
			return Rect2Str(vRetPosition);
		else
		{
			vPosition.width = 0;
			vPosition.height = 0;
		}
	}

	vRetPosition.right = vRetPosition.left + (vPosition.width + nOffsetWidth);
	vRetPosition.bottom = vRetPosition.top + (vPosition.height + nOffsetHeight);

	return Rect2Str(vRetPosition);
}

/*******************************************************************************
 ★ 설명
     sPosition대비 
     Left좌표에 대해 nOffsetLeft만큼, Top좌표에 대해 nOffsetTop만큼,
     Width에 대해 n Offset Width만큼, Height에 대해 n Offset Height만큼 
     이동한 좌표 Position문자열을 획득한다.
 ★ parameter 
    1. sPosition     : position 문자열 (예 : "absolute 10 10 20 20" = object.position ) 
                       단, "absolute"는 생략 가능하다.
    2. nOffsetLeft   : sPosition대비 이동할 Left Offset값 ( 예 : 10 또는 -10 )
    3. nOffsetTop    : sPosition대비 이동할 Left Offset값 ( 예 : 10 또는 -10 )
    4. nOffsetWidth  : sPosition대비 이동할 Width Offset 값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
    5. nOffsetHeight : sPosition대비 이동할 Height Offset 값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
 ★ return 
    - 성공 = 이동될 Position문자열 ( 예 : "absolute 20 20 30 30" 또는 "absolute 0 0 10 10" )
              단, sPosition이 2개만 지정된 경우 offsetWidth, nOffsetHeight에 어떤값을 지정하면
              이 경우는 Widht=0, Height=0와 동일하므로 4개로 바꾸어 Return한다.
              ( 예 : GetMovePos("10 10", 20, 20) = "20 20 20 20" )
    - 실패 = "" 
 ******************************************************************************/
function GetMoveToPos(sPosition, nOffsetLeft, nOffsetTop, nOffsetWidth, nOffsetHeight)
{
	var nLeft, nTop;
	var vPosition;	
	
	if( IsNull(sPosition) || IsNull(nOffsetLeft) || IsNull(nOffsetTop) )	return "";
	
	if( IsNull(nOffsetWidth) )
		nOffsetWidth = 0;
	if( IsNull(nOffsetHeight) )
		nOffsetHeight = 0;

	vPosition = Str2Rect(sPosition);
	if( IsNull(vPosition) )		return "";

	nLeft = vPosition.left + nOffsetLeft;
	nTop = vPosition.top + nOffsetTop;	

	return GetMovePos(sPosition, nLeft, nTop, nOffsetWidth, nOffsetHeight);
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 Object의 border width를 구하는 함수이다.
 ★ parameter 
    1. oObj : Object 
       (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = oObj의 Border Width
    - 실패 = -1    
 ★ 목적    
    현재 XPlatform(2009.12.10.1)에서 border가 지정되지 않고 style로 적용되어 있으면
    border를 구하지 못하므로 만들었다.
 ******************************************************************************/
function GetObjBorderWidth(oObj)
{
	if( IsNull(oObj) )	return -1;
	if( IsObjNoPos(oObj) ) 	return -1;

	if( IsNull(oObj.style.border.width) || IsNull(oObj.style.border.width) )
	{
		var sType;	
		
		sType = GetObjType(oObj);
		if( IsObjScreenPos(oObj) == true )
			return 0-system.screenToClientX(oObj, oObj.position.left);
		else
		{
			if( GetObjType(oObj.parent).toLowerCase() == "form" )
				return 0;
			else
				return system.clientToScreenX(oObj, 0) - system.clientToScreenX(oObj, oObj.position.left);
		}
	}
	else
		return oObj.style.border.width;
}


/*******************************************************************************
 ★ 설명
     oFromObj 좌표계의 sFromObjPos에 해당하는 Position을
     oToObj 좌표계에 해당하는 Position으로 바꾼다.
 ★ parameter 
	1. sFromPos : 변경하고자 하는 oFromAreaObj좌표계 내에서의 Position
	            (예 : "10 10" 또는 "10 10 20 20", Button.position, ...)
    2. oFromAreaObj : 변경할 좌표계 Object,
                  단, Screen의 경우는 "screen"을 넣으면 된다.
				(예 : "screen", mainframe, this,...)
    3. oToAreaObj  : 변경할 좌표계 Object
                 단, Screen의 경우는 "screen"을 넣으면 된다. 
				(예 : "screen", mainframe, this,...)
 ★ return 
    - 성공 = oToObj 좌표계로 변경된  position 문자열 
    - 실패 = ""
 ★ 목적
	ScreenToClient, ClientToScreen 밖에 없고 A Object에서 B Object좌표계로
	한번에 변경하는 함수가 없어서 만들었음 
 ★ BUG
 	oFromAreaObj = form, oToAreaObj = "screen"인 경우 잘 안됨(???(모름))
 ******************************************************************************/
function GetObjConvPos(sFromPos, oFromAreaObj, oToAreaObj)
{
	var vFromPos;
	var vRetPos = new Rect();

	if( IsNull(sFromPos) || IsNull(oFromAreaObj) || IsNull(oToAreaObj) )		return "";
	if( IsObjNoPos(oFromAreaObj) ) 	return "";	
	if( IsObjNoPos(oToAreaObj) ) 	return "";		
	
	if( oFromAreaObj == oToAreaObj )
		return sFromPos;
	vFromPos = Str2Rect(sFromPos);
	if( IsNull(vFromPos) )		return "";
	
	if( oFromAreaObj.toString().toLowerCase() == "screen" )
	{
		vRetPos.left = system.screenToClientX( oToAreaObj, vFromPos.left );
		vRetPos.top = system.screenToClientY( oToAreaObj, vFromPos.top );
	}
	else if( oToAreaObj.toString().toLowerCase() == "screen" )
	{
		vRetPos.left = system.clientToScreenX( oFromAreaObj, vFromPos.left );
		vRetPos.top = system.clientToScreenY( oFromAreaObj, vFromPos.top );
	}
	else
	{
		vRetPos.left = system.clientToScreenX( oFromAreaObj, vFromPos.left );
		vRetPos.top = system.clientToScreenY( oFromAreaObj, vFromPos.top );
		vRetPos.left = system.screenToClientX( oToAreaObj, vRetPos.left );
		vRetPos.top = system.screenToClientY( oToAreaObj, vRetPos.top );
	}
	if( IsPoint(vFromPos) == false )
	{
		vRetPos.right = vRetPos.left + vFromPos.width;
		vRetPos.bottom = vRetPos.top + vFromPos.height;
	}
	return Rect2Str(vRetPos);	
}

/*******************************************************************************
 ★ 설명 
    sAreaPos좌표계 내에서 주어진 Align 조건에 따라 
    sObjPos의 좌표를 재 계산한다.
 ★ parameter 
    1. sAreaPos   : Object가 움직일 좌표영역에 해당하는 Position 문자열 ( 예 : "10 10 100 100" )
    2. sObjPos    : Align될 Object의 현재 Position문자열 ( 예 : "50 50 60 60" )
    3. sAxisPos   : 기준이 되는 X,Y축 Position문자열
					( 옵션 : Default=""==>sAreaPos의 center ) ( 예 : "60 60" )
    4. sOffsetPos : sAxisPos로부터의 Offset Position문자열 
                    ( 옵션 : Default="0 0" ) ( 예 : "10 10" 또는 "-10 -10" )
    5. nAlign     : sAxisPos를 기준으로 한 정렬형태 ( 옵션 : Default=0 )
                    0 = 중앙정렬, 1 = 1사분면, 2 = 2사분면, 3 = 3사분면, 4 = 4사분면
    6. bAuto      : nAlign을 기준으로 sObjPos의 Width, Height가 들어갈 수 있는
                    사분면을 자동으로 찾아 정렬한다.( 옵션 : Default=true )
                    true = 자동정렬, false = 자동정렬 하지 않음
    7. bBigResize : Object의 width, height가 해당 4분면의 영역보다 크면 4분면에 맞추어 
                    Object의 width, height를 줄여서 조정한다. 
                    즉, obj > Area이면 obj를 Area의 사분면에 맞춰 줄인다. ( 옵션 : Default = false )
                    true = Size 조정, false = Size 조정하지 않음
    8. bSmallResize : Object의 width, height가 해당 4분면의 영역보다 작으면 4분면에 맞추어 
                    Object의 width, height를 늘려서 조정한다. 
                    즉, obj < Area이면 obj를 Area의 사분면에 맞춰 늘인다. ( 옵션 : Default = false )
                    true = Size 조정, false = Size 조정하지 않음
 ★ return 
    - 성공 = 주어진 조건에 맞는 정렬된 Object의 Position문자열
    - 실패 = ""
 ★ 주의사항
    1. bAuto와 (bBigResize, bSmallResize)는 동시에 true일 수 없다.
       bAuto가 true이면 bBigResize, bSmallResize는 false로 처리된다.
    2. (sAxisPos+sOffsetPos)가 sAreaPos의 범위를 벗어나면 null이 return된다.
       단, sObjPos의 최종 Align된 Position은 sAreaPos의 범위를 벗어날 수도 있다.
    2. 모든 Position은 sAreaPos의 좌표계에 맞도록 전달되어야 한다.
       따라서, 머리가 아프다면 모든 좌표를 screen좌표로 처리한다면 
       좀 더 쉬워지겠지...
 ******************************************************************************/
function GetAlignPos( sAreaPos, sObjPos, sAxisPos, sOffsetPos, nAlign, bAuto, bBigResize, bSmallResize )
{
	var vAreaPos;
	var vAxisPos = new Rect();
	var vObjPos;
	var vOffsetPos;
	var vAlignPos = new Rect();

	if( IsNull(sAreaPos) || IsNull(sObjPos) )	return "";
	
	if( IsNull(sAxisPos) )
		sAxisPos = "";
	if( IsNull(sOffsetPos) )
		sOffsetPos = "0 0";
	if( IsNull(nAlign) )
		nAlign = 0;
	if( IsNull(bAuto) )
		bAuto = false;
	if( IsNull(bBigResize) )
		bBigResize = false;
	if( IsNull(bSmallResize) )
		bSmallResize = false;
		
	vAreaPos = Str2Rect(sAreaPos);
	if( IsNull(vAreaPos) )	return "";
	vObjPos = Str2Rect(sObjPos);	
	if( IsNull(vObjPos) )	return "";
	if( sAxisPos != "" )
	{
		vAxisPos = Str2Rect(sAxisPos);
		if( IsNull(vAxisPos) )	return null;
	}
	else
	{
		vAxisPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1);
		vAxisPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1);
	}

	vOffsetPos = Str2Rect(sOffsetPos);
	if( IsNull(vOffsetPos) )	return "";

	if( bAuto == true )
	{
		bBigResize = false;
		bSmallResize = false;
	}

	// Axis를 Offset만큼 보정
	vAxisPos.left += vOffsetPos.left;
	vAxisPos.top += vOffsetPos.top;
	
	// Axis가 Area의 범위를 벗어나면 return null
	if( vAxisPos.left < vAreaPos.left )
		return "";
	if( vAxisPos.left > vAreaPos.right ) 
		return "";
	if( vAxisPos.top < vAreaPos.top ) 
		return "";
	if( vAxisPos.top > vAreaPos.bottom ) 
		return "";
	
	// Center에 위치
	if( nAlign == 0 )
	{
		vAlignPos.left = vAxisPos.left - Math.round(vObjPos.width/2,1);
		vAlignPos.top = vAxisPos.top - Math.round(vObjPos.height/2,1);
	}
	// 1사분면에 위치
	else if( nAlign == 1 )
	{
		vAlignPos.left = vAxisPos.left;
		vAlignPos.top = vAxisPos.top - vObjPos.height;
	}
	// 2사분면에 위치	
	else if( nAlign == 2 )
	{
		vAlignPos.left = vAxisPos.left - vObjPos.width;
		vAlignPos.top = vAxisPos.top - vObjPos.height;
	}
	// 3사분면에 위치	
	else if( nAlign == 3 )
	{
		vAlignPos.left = vAxisPos.left - vObjPos.width;
		vAlignPos.top = vAxisPos.top;
	}
	// 4사분면에 위치
	else if( nAlign == 4 )
	{
		vAlignPos.left = vAxisPos.left;
		vAlignPos.top = vAxisPos.top;
	}
	
	vAlignPos.right = vAlignPos.left + vObjPos.width;
	vAlignPos.bottom = vAlignPos.top + vObjPos.height;

	// Auto처리
	if( bAuto == true )
	{
		var i;
		var aAlignPosAuto, sAlignPosAuto, nCurAlign;
		if( nAlign != 0 )
		{
			for( i = 0 ; i <= 4 ; i++ )
			{
				nCurAlign = (nAlign+i)%5;
				if( nCurAlign == 0 )	
					continue;
				sAlignPosAuto = GetAlignPos( sAreaPos, sObjPos, sAxisPos, sOffsetPos, 
												 nCurAlign, false, false, false );
				vAlignPosAuto = Str2Rect(sAlignPosAuto);
				if( (vAlignPosAuto.left >= vAreaPos.left) &&
					(vAlignPosAuto.right <= vAreaPos.right) &&
					(vAlignPosAuto.top >= vAreaPos.top) &&
					(vAlignPosAuto.bottom <= vAreaPos.bottom) )
				{
					vAlignPos = vAlignPosAuto;
					break;
				}
			}
		}
	}

	// Resize처리
	if( bBigResize == true || bSmallResize == true )
	{
		if( nAlign == 1 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.right > vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.top < vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.right < vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.top > vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
		}
		if( nAlign == 2 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.left < vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.top < vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.left > vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.top > vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
		}
		if( nAlign == 3 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.left < vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.bottom > vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.left > vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.bottom < vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
		}
		if( nAlign == 4 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.right > vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.bottom > vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.right < vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.bottom < vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
		}
		// Axis를 중심으로 작은 쪽에 맞추어 Resizing한다.
		if( nAlign == 0 )
		{
			var nSmallWidth, nSmallHeight;
			nSmallWidth = Math.min(vAxisPos.left - vAreaPos.left, vAreaPos.right - vAxisPos.left);
			nSmallHeight = Math.min(vAxisPos.top - vAreaPos.top, vAreaPos.bottom - vAxisPos.top);

			var bWFlag=false, bHFlag=false;		
			if( bSmallResize == true )
			{
				if( Math.round(vObjPos.width/2,1) < nSmallWidth )
					bWFlag = true;
				if( Math.round(vObjPos.height/2,1) < nSmallHeight )
					bHFlag = true;
			}
			if( bBigResize == true )
			{
				if( Math.round(vObjPos.width/2,1) > nSmallWidth )
					bWFlag = true;
				if( Math.round(vObjPos.height/2,1) > nSmallHeight )
					bHFlag = true;
			}
			if( bWFlag == true )
			{
				vAlignPos.left = vAxisPos.left - nSmallWidth;
				vAlignPos.right = vAxisPos.left + nSmallWidth;
			}
			if( bHFlag == true )
			{
				vAlignPos.top = vAxisPos.top - nSmallHeight;
				vAlignPos.bottom = vAxisPos.top + nSmallHeight;
			}
		}
	}

	vAlignPos.width = vAlignPos.right - vAlignPos.left;
	vAlignPos.height = vAlignPos.bottom - vAlignPos.top;

	return Rect2Str(vAlignPos);
}

/*******************************************************************************
 ★ 설명
    nX, nY좌표를 nCx, nCy를 중심으로 nAngle만큼 회전한 좌표를 구한다.
 ★ parameter 
    1. nX : 회전할 X좌표
    2. nY : 회전할 Y좌표
    3. nCx : 회전 중심 X좌표
    4. nCy : 회전 중심 Y좌표
    5. nAngle : 회전 각(※ radian, 숫자값이 아니다.)(예:Math.PI, Math.PI/2,...)
 ★ return 
    1. 성공 = Rect Object( 단, Rect.left = 회전된 X좌표, Rect.top = 화전된 Y좌표 )
    2. 실패 = null
******************************************************************************/ 
function RotatePoint(nX, nY, nCx, nCy, nAngle)
{
	var vPoint = new Rect();
	
	if( IsNull(nX) || IsNull(nY) || IsNull(nCx) || IsNull(nCy) || IsNull(nAngle) )
		return null;

	nY = -1*nY;
	nCy = -1*nCy;
	vPoint.left = nCx + Math.round(Math.cos(nAngle)*(nX-nCx) - Math.sin(nAngle)*(nY-nCy),1);
	vPoint.top = nCy + Math.round(Math.sin(nAngle)*(nX-nCx) + Math.cos(nAngle)*(nY-nCy),1);
	vPoint.top = -1*vPoint.top;

	return vPoint;
}

/*******************************************************************************
 ★ 설명
    A직선(Start ~ End)과 B직선(Start ~ End)의 교차점을 구한다.
 ★ parameter 
    1. nA_StartX : A직선의 Start X값
    2. nA_StartY : A직선의 Start Y값    
    3. nA_EndX   : A직선의 End X값
    4. nA_EndY   : A직선의 End Y값    
    5. nB_StartX : B직선의 Start X값
    6. nB_StartY : B직선의 Start Y값    
    7. nB_EndX   : B직선의 End X값
    8. nB_EndY   : B직선의 End Y값     
 ★ return 
    1. 성공 = Rect Object( 단, Rect.left = 교차점 X좌표, Rect.top = 교차점 Y좌표 )
    2. 실패 = null
 *****************************************************************************/ 
function CrossPoint(nA_StartX, nA_StartY, nA_EndX, nA_EndY,
				    nB_StartX, nB_StartY, nB_EndX, nB_EndY)	
{
	var vPoint = new Rect();
	var nA_Angle, nB_Angle;

	if( IsNull(nA_StartX) || IsNull(nA_StartY) || IsNull(nA_EndX) || IsNull(nA_EndY) || 
		IsNull(nB_StartX) || IsNull(nB_StartY) || IsNull(nB_EndX) || IsNull(nB_EndY) )
		return null;
			
	nA_StartY = -1*nA_StartY;
	nB_StartY = -1*nB_StartY;	
	nA_EndY = -1*nA_EndY;	
	nB_EndY = -1*nB_EndY;		
	nA_Angle = Math.tan(Math.atan2((nA_EndY - nA_StartY), (nA_EndX - nA_StartX)));
	nB_Angle = Math.tan(Math.atan2((nB_EndY - nB_StartY), (nB_EndX - nB_StartX)));	
	
	// 평행한 경우
	if( Math.abs(Deg2Rad(nA_Angle - nB_Angle))%180  == 0 )
		return null;
		
	vPoint.left = (nA_StartY - nB_StartY - nA_Angle*nA_StartX + nB_Angle*nB_StartX)/(nB_Angle - nA_Angle);
	vPoint.top = nA_StartY - nA_Angle*(nA_StartX - vPoint.left);
	
	vPoint.left = Math.round(vPoint.left,1);
	vPoint.top = -1*Math.round(vPoint.top,1);
	
	return vPoint;
}

///////////////////////////////////////////////////////////////////////////////
// Biz Validation Start
///////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    사업자 등록번호 확인
 ★ Parameter 
    1. sValue : 사업자 등록 번호
 ★ return 
    - sValue가 사업자등록번호 형식에 맞는 경우 = true
    - sValue가 사업자등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsCompRegNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
    var vCompNo = sValue.replace("-", "");
	var checkID = new Array(1, 3, 7, 1, 3, 7, 1, 3, 5, 1);
	var i, Sum=0, c2, remander;
	
	if (vCompNo.length != 10) 
		return false; 
	
	for (i = 0; i <= 7; i++) 
		Sum += checkID[i] * vCompNo.charAt(i);

	c2 = "0" + (checkID[8] * vCompNo.charAt(8));
	c2 = c2.substring(c2.length - 2, c2.length);

	Sum += Math.floor(c2.charAt(0)) + Math.floor(c2.charAt(1));

	remander = (10 - (Sum % 10)) % 10;

	if (Math.floor(vCompNo.charAt(9)) != remander) 
		return false;
	return true;
}

/*******************************************************************************
 ★ 설명
    법인 등록번호 확인
 ★ Parameter 
    1. sValue : 법인 등록 번호
 ★ return 
    - sValue가 법인등록번호 형식에 맞는 경우 = true
    - sValue가 법인등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsCorpRegNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
	var vCorpNo = sValue.replace("-", "");
	var checkID = new Array(1,2,1,2,1,2,1,2,1,2,1,2);
	var i, Sum=0, c2, remander;
	
	if (vCorpNo.length != 13) 
		return false; 
	
	for (i = 0; i <= 12; i++) 
		Sum += checkID[i] * vCorpNo.charAt(i);
	
	remander = Sum / 10;
	var nIndex = remander.toString().indexOf(".");	
	remander = remander.toString().substring(nIndex+1,nIndex+2);
	remander = 10 - remander; 
	
	if (remander > 9 ) 
		remander = 0;
	if (remander == sValue.substring(12, 13)) 
		return true;

	return false
}

/*******************************************************************************
 ★ 설명
    주민 등록번호 확인
 ★ Parameter 
    1. sValue : 주민 등록 번호
 ★ return 
    - sValue가 주민등록번호 형식에 맞는 경우 = true
    - sValue가 주민등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsRsrNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
    var v_JuminNo = sValue.replace("-", "");
	var v_JuminChkDgt = [2,3,4,5,6,7,8,9,2,3,4,5];
	var v_FNum = new Number();
	var v_LNum = new Number();
	var v_iSum = new Number();
	var v_RtnVal;
	var v_YY;

    if(v_JuminNo.length != 13) 
        return false;
	
	v_FNum = v_JuminNo.substr(0, 6).toString();
	v_LNum = v_JuminNo.substr(6).toString();
  
    if (v_LNum.substr(0,1) == '1' ||  v_LNum.substr(0,1) == '2')
        v_YY  = '19';
    else if (v_LNum.substr(0,1) == '3' ||  v_LNum.substr(0,1) == '4') 
        v_YY  = '20';
    else
		return false;
    
    if(IsDate(v_YY + v_FNum) == false)
		return false;

    if (IsNum(v_JuminNo) == false)
		return false;

	for ( ix = 0; ix < 12 ; ix++)
		v_iSum += (parseInt(v_JuminNo.substr(ix, 1)) * v_JuminChkDgt[ix]);
		
	v_iSum = 11 - (v_iSum%11);
	v_iSum = v_iSum % 10;
	if (v_iSum != (parseInt(v_JuminNo.substr(12, 1))))
		return false;

	return true; 
}


/*******************************************************************************
 ★ 설명
    Email 적합여부 확인
 ★ Parameter 
    1. sValue : Email ( 예 : "oju@yahoo.co.kr" )
 ★ return 
    - sValue가 Email형식에 맞는 경우 = true
    - sValue가 Email형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
 *****************************************************************************/ 
function IsEmail(sValue)
{   
	var vChk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._@";
	var i, pos, vEmailFirst, vEmailLast;
	
	if( IsNull(sValue) )	return false;
	
	for( i = 0 ; i < sValue.length ; i++)
	{
		if(vChk.indexOf(sValue.charAt(i)) < 0) 
			return false;
    }
    pos = Pos(sValue,"@");
    if( pos < 0 )
		return false;
		
	vEmailFirst = sValue.substr(0, pos);
	vEmailLast = sValue.substr(pos+1);
	if( vEmailFirst.length <= 0 || vEmailLast.length <= 0 )
		return false;
	if( Pos(vEmailLast, ".") <= 0 || Pos(vEmailLast, "..") >= 0 || Right(vEmailLast,1) == "." )
		return false;
	if( Pos(vEmailLast, "@") >= 0 )
		return false;
		
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// Component관련 함수 Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
     Grid Sorting하는 함수(Header Sorting여부 표시 포함)
 ★ parameter 
    1. obj:Grid : Grid Object ( 예 : Grid00 )
    2. e:GridClickEventInfo : Click Event Object ( Grid Onclick Envent의 Argument e )
    3. ASC_MARK : Ascending Mark (옵션 : Default = "▼")( 예 : "▼" )
    4. DESC_MARK : Descending Mark (옵션 : Default = "▲")( 예 : "▲" )
    5. sSortMark    : Sorting 강제 지정 (옵션 : Default = "" ==> 상태에 따라 알아서 함)
                      (예 : ASC_MARK 또는 DESC_MARK 지정 )
 ★ return 
    - 성공 = true
    - 실패 = false
 ******************************************************************************/ 
function GridSort(obj:Grid, e:GridClickEventInfo, ASC_MARK, DESC_MARK, sSortMark)
{
	if( IsNull(obj) || IsNull(e) )	return false;
	
	// 컬럼의 정렬방식을 'head'의 text에 "↑,↓"여부로 판단.
	// 이미지로 대체 가능.
	var bindDs = eval(obj.binddataset);
	var i, cell_cnt;
	
	if (bindDs.rowcount == 0) return false;
	if( IsNull(ASC_MARK) )		ASC_MARK = "▼";
	if( IsNull(DESC_MARK) )		DESC_MARK = "▲";
	
	cell_cnt = obj.getCellCount("head");
	var BodyColId = (obj.getCellProperty("body", e.col,"text")).toString().split(":");	// e.col : 바인드된 컬럼.
																					
	for( i = 0 ; i < cell_cnt ; i++ ) 
	{
		if(obj.getCellText(-1, i)=="undefined")
			continue;
		
		var strHeadText = obj.getCellText(-1, i);	

		if(i==e.cell)
		{
			if(strHeadText.substr(strHeadText.length-1) == ASC_MARK) 
			{
				if( IsNull(sSortMark) || sSortMark == DESC_MARK )
				{
					obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1)+DESC_MARK);
					bindDs.keystring = "S:-"+BodyColId[1];
				}
			}
			else if (strHeadText.substr(strHeadText.length-1) == DESC_MARK) 
			{
				if( IsNull(sSortMark) || sSortMark == ASC_MARK )
				{
					obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1)+ASC_MARK);
					bindDs.keystring = "S:+"+BodyColId[1];
				}
			}
			else
			{
				var def_mark;
				if( IsNull(sSortMark) )	def_mark = ASC_MARK;
				else					def_mark = sSortMark;
					
				obj.setCellProperty( "head", i, "text", strHeadText+def_mark);
				if( def_mark == ASC_MARK )
					bindDs.keystring = "S:+"+BodyColId[1];
				else 
					bindDs.keystring = "S:-"+BodyColId[1];
			}
		}
		else	// 정렬표시 삭제
		{
			if (strHeadText.substr(strHeadText.length-1) == ASC_MARK || strHeadText.substr(strHeadText.length-1) == DESC_MARK) 
			{
				obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1));
			}
		}
	}
	return true;
}

/*********************************************************************************************
 ★ 설명
     Grid Excel Export하는 함수
 ★ parameter 
    1. obj:Grid : Grid Object ( 예 : Grid00 )
    2. ExpObj:ExportObject : Export Object (옵션 : Default는 생성해서 처리됨)
    3. sSheetName : Sheet 명 ( 옵션 : Default="Sheet1" )
 ★ return 
    - 성공 = true
    - 실패 = false
*********************************************************************************************/
function GridExportExcel(obj:Grid, ExpObj:ExportObject, sSheetName) 
{
	if( IsNull(obj)	)	return false;
	
	if( IsNull(ExpObj) == true )	
		var ExpObj = new ExportObject;
	if( IsNull(sSheetName) == true )
		sSheetName = "Sheet1";
		
	ExpObj.exportfilename = Grid.name+".xls"; 	// 꼭 줘야됨
	ExpObj.exporttype     = ExportTypes.EXCEL;	// 현재 Excel만 가능합니다.	
	ExpObj.activepagename = sSheetName;
	
	ExpObj.addExportItem(ExportItemTypes.GRID, obj, sSheetName+"!A1");	
	ExpObj.export();	// Excel로 Export실행
	
	return true;
}

/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 nCurRow의 sLevelCol에 해당하는 현재 Level보다 
     0 ~ (nCurRow-1) Record중 더 상위의 Level(bFlag에 따라)에  해당하는 Record를 
     모두 구해 Array로 Return한다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
    4. bInclude    : 현재 level을 포함할 지 여부 ( 예 : true ) ( Default = true )
                     - true = 상위의 Level을 찾을 때 nCurRow Level과 동일한 Level도 포함
                     - false = 상위의 Level을 찾을 때 nCurRow Level과 동일한 Level은 포함 안함
 ★ return 
    - 성공 = Array ( record번호만 들어있음 )
    - 실패 = 빈 Array
*********************************************************************************************/
function TreeGetParentList(obj:Dataset, sLevelCol, nCurRow, bInclude) 
{
	var i, nLevel, nChkLevel;
	var aRet = new Array(), aNo=0;
	var bFlag;
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return aRet;
		
	if( IsNull(bInclude) == true )	bInclude = true;
	
	if( bInclude == true )
		nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol));
	else
		nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol))-1;
	for( i = (nCurRow-1) ; i >= 0 ; i-- )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel <= nChkLevel )
		{
			aRet[aNo] = i;
			aNo++;
			nChkLevel = nLevel;
		}
	}
	return aRet.sort();
}

/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 0 ~ (nCurRow-1)의 Record중
     nOffsetLevel에 해당하는 시작 부모 Record를 찾는다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
    4. nOffsetLevel    : 양수(0, 음수는 안됨)에 해당하는 검색할 Offset Level ( 옵션 : Default = 1 )
                         ( 예 : 1 = 나보다 1 Level 위의 Parent의 시작 Record를 찾으라는 뜻 )
 ★ return 
    - 성공 = Start Record
    - 실패 = -1
 ★ 주의사항
    nOffsetLevel은 0 또는 음수를 주면 안된다.
*********************************************************************************************/
function TreeGetParentStart(obj:Dataset, sLevelCol, nCurRow, nOffsetLevel) 
{
	var i, nLevel, nChkLevel, nStartRow = -1;
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return -1;

	if( IsNull(nOffsetLevel) == true )	nOffsetLevel = 1;
	if( nOffsetLevel <= 0 )		
		return -1;
	
	nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol)) - nOffsetLevel;
	for( i = (nCurRow-1) ; i >= 0 ; i-- )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel == nChkLevel )
		{
			nStartRow = i;
			break;
		}
		if( nLevel < nChkLevel )
			nChkLevel = nLevel;
	}
	
	return nStartRow;
}


/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 nCurRow+1 ~ 끝 Record중
     nCurRow의 Level이하의 Child Level이 끝나는 Record를 찾는다.
     즉, 자식이 끝나는 Record를 찾는다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
 ★ return 
    - 성공 = End Record
    - 실패 = -1
*********************************************************************************************/
function TreeGetChildEnd(obj:Dataset, sLevelCol, nCurRow) 
{
	var i, nLevel, nChkLevel, nEndRow = (obj.rowcount - 1);
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return -1;
	
	nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol));	

	for( i = (nCurRow+1) ; i < obj.rowcount ; i++ )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel <= nChkLevel )
		{
			nEndRow = i-1;
			break;
		}
	}
	
	return nEndRow;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath의 그리기 영역을 구한다.
     GraphicPath에서 Border와 Pen의 크기를 뺀 영역을 의미한다.
 ★ parameter 
    1. obj : GraphicPath Object ( 예 : GraphicPath00 )
    2. nLeftOffset : GrapicPath의 영역 중 Left에서 안쪽으로 들어가는 Offset값
					 (옵션 : Default = 0) (예 : nLeftOffset=10이면 10만큼 Left에서 떨어진 지점이 영역으로 잡힘)
    3. nTopOffset : GrapicPath의 영역 중 Top에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = 0) (예 : nTopOffset=10이면 10만큼 Top에서 떨어진 지점이 영역으로 잡힘)
    4. nRightOffset : GrapicPath의 영역 중 Right에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = nLeftOffset) (예 : nLeftOffset=10이면 10만큼 Right에서 떨어진 지점이 영역으로 잡힘)
    5. nBottomOffset : GrapicPath의 영역 중 Bottom에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = nBottomOffset) (예 : nLeftOffset=10이면 10만큼 Bottom에서 떨어진 지점이 영역으로 잡힘)★ return 
 ★ Return    					
    - 성공 = Rect Object
    - 실패 = null 
			(단, offset이 너무커서 width나 height값보다 클 경우도 null이 return된다.)
 ★ 목적    
    GraphicPath.position을 이용하여 그리면 제대로 안되는 것을 알 수 있다. 그래서, 만들었다. Offset도 줄겸
 ★ BUG
    이 함수도 제대로 되는게 아니다. 나도 정확히 우찌해야 할지 잘 모르겠다. ???(모름)
*********************************************************************************************/
function GPRect(obj:GraphicPath, nLeftOffset, nTopOffset, nRightOffset, nBottomOffset)
{
	var GR = new Rect();
	var border, pen;
	
	if( IsNull(obj) ) 	return null;
	
	if( IsNull(nLeftOffset) )	nLeftOffset = 0;
	if( IsNull(nTopOffset) )	nTopOffset = 0;
	if( IsNull(nRightOffset) )	nRightOffset = nLeftOffset;
	if( IsNull(nBottomOffset) )	nBottomOffset = nTopOffset;

	border = ( "x"+obj.style.border.width == "xNaN" ? 0 : obj.style.border.width );
	pen = ( "x"+obj.strokepen.width == "xNaN" ? 1 : obj.strokepen.width );
	GR.left = nLeftOffset;
	GR.top = nTopOffset;
	
	// 이렇게 하는게 최선이다.
	GR.right = obj.position.width - nRightOffset - 2*border - pen;
	GR.bottom = obj.position.height - nBottomOffset - 2*border - pen;
	if( GR.width < 0 || GR.height < 0 )
		return null;
	
	return GR;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath처리 시 화살표처리 Data를 만들어 준다.
     이미 그려놓은 GraphicPath.data에 이 함수에서 return된 data를 덧붙여 처리해서 사용한다.
 ★ parameter 
    1. obj:GraphicPath : GraphicPath Object ( 예 : GraphicPath00 )
    2. nArrowType  : 화살표의 종류( 예 : 1 )
       - 0 = 화살표 안그림
       - 1 = ---> 화살표
       - 2 = ---▶ 화살표
       - 3 = ---◆ 화살표
       - 4 = ---● 화살표
    3. nEndX, nEndY, nDirAngle : 화살표의 위치 및 화살표 방향
       - nEndX, nEndY : 화살표의 끝좌표
       - nAngle       : 화살표의 방향, 단 Radian값이다.
                        화살표 끝좌표의 가로축과 시작방향이 이루는 각이다.
                        (※ GetAngle()함수를 이용하면 쉽게 구할 수 있다.)
       (예 : (15,15) ----> (20,20) 으로 화살표를 그리고 싶다면
             nEndX = 20, nEndY = 20, nAngle = Deg2Rad(-45) )
    4. 화살표가 그려질 선을 중심으로 화살표의 넓이와 높이
       1) nArrowW : 화살표 넓이
       2) nArrowH : 화살표 높이
       (※ 단, ---●의 경우 타원처리는 안되고 nArrowW, nArrowH중 작은 쪽을 반지름으로 하는 원만 처리한다. )
                    (20)
       (예 : -----(0)▶(10) ==> nArrowW = 10, nArrowH = 20 )
                     (0)
                    (20)
       (예 : -----(0)◆(10) ==> nArrowW = 10, nArrowH = 20 )
                     (0)
 ★ return 
    - 성공 = GraphicPath.data에 들어갈 화살표 Data
    - 실패 = ""
*********************************************************************************************/
function GPArrow(obj:GraphicPath, nArrowType,
					nEndX, nEndY, nAngle, nArrowW, nArrowH )
{
	var D="";
	
	var nDirX, nDirY;
	var nArrowOrgX, nArrowOrgY, nArrowCoW, nArrowCoH, nArrowDist;
	var nArrowType;

	if( IsNull(obj) || IsNull(nArrowType) || IsNull(nEndX) || IsNull(nEndY) || 
		IsNull(nAngle) || IsNull(nArrowW) || IsNull(nArrowH) )
		return "";
		
	// ->, ▶
	if( nArrowType == 1 || nArrowType == 2 )	
	{
		nArrowCoW = nArrowW;
		nArrowCoH = Math.round(nArrowH/2,1);
	}
	// ◆, ●
	else if( nArrowType == 3 || nArrowType == 4 )
	{
		nArrowCoW = Math.round(nArrowW/2,1);
		nArrowCoH = Math.round(nArrowH/2,1);		
	}
	else
		return "";
	
	if( nArrowType == 4 )
		nArrowDist = Math.min(nArrowW,nArrowH);
	else
		nArrowDist = Math.sqrt(Math.pow(nArrowCoW,2)+Math.pow(nArrowCoH,2));
	nArrowOrgX = nEndX + nArrowDist*Math.cos(nAngle);
	nArrowOrgY = nEndY - nArrowDist*Math.sin(nAngle);
/*	
D  = " M " + nEndX + " " + nEndY;
D += " L " + nArrowOrgX + " " + nArrowOrgY;
return D;
*/
	// ->
	if( nArrowType == 1 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2;	
		
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );		
					
		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " M " + nEndX + " " + nEndY;				
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
	}
	// ▶
	if( nArrowType == 2 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2;	
	
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );		

		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
		D += " L " + nEndX + " " + nEndY;				
	}
	// ◆
	if( nArrowType == 3 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2, vRotatePoint3;	
		
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );
		vRotatePoint3 = RotatePoint( nEndX, nEndY, vRotatePoint1.left, vRotatePoint1.top, Math.PI-2*nArrowAngle );
		
		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " L " + vRotatePoint3.left + " " + vRotatePoint3.top;
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
		D += " L " + nEndX + " " + nEndY;			
	}
	// ●
	if( nArrowType == 4 )
	{
		var nRX, nRY;

		nRX = nRY = Math.min(nArrowCoW,nArrowCoH);
		D += " M " + nEndX + " " + nEndY;	
		D += " A " + nRX + " " + nRY + " 180 0 1 " + nArrowOrgX + " " + nArrowOrgY;		
		D += " A " + nRX + " " + nRY + " 180 0 1 " + nEndX + " " + nEndY;				
	}
	return D;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath.data를 2차원 Array로 반환한다.
     단순히 Parsing만 하며 Array의 순서는 GraphicPath.data의 순서를 그대로 따른다.
     단, type이 중복되어 생략되는 경우(예: V 100 100) Array가 추가되고 첫번째 요소는 ""가 들어간다.
     (아래 예를 참고할것)
 ★ parameter 
    1. sGpData : GraphicPath.data ( 예 : "M 0 0 L 100 100 H 100 V 100 100" )
 ★ return 
    - 성공 = 2차원 Array 
             ( 예 : Array ==> { {M,0,0}, {L,100,100}, {H,100}, {V,100}, {,100} }
    - 실패 = 빈 Array
 ★ 목적    
    GraphicPathData Object가 있었다가 사라졌다.
 ★ 참고사항
    aGpData로 data문자열을 만들고 싶다면 ==> GraphicPath.data = aGpData.join(" "); 로 처리하면 된다.
 ********************************************************************************************/
function AGPData(sGpData)
{
	var aGpData = new Array();
	var arr = new Array();
	var i, gi_no=-1, ho_no, val, sType, ho_num;
	
	if( IsNull(sGpData) ) 	return aGpData;

	sGpData = sGpData.toString();
	arr = sGpData.split(" ");
	for( i = 0 ; i < arr.length ; i++ )
	{
		val = RTrim(LTrim(arr[i]));
		if( IsAlpha(val) == true )
		{
			gi_no++;
			ho_no = 0;
			
			var aHor = new Array();	// 2차원 배열의 가로 배열
			aGpData[gi_no] = aHor;
			aGpData[gi_no][ho_no] = val;
			sType = val;
		}
		else if( IsNum(val) == true )
		{
			ho_no++;		
			if( ( (sType == "M" || sType == "m") && ho_no == 3) ||
				( (sType == "L" || sType == "l") && ho_no == 3) ||
				( (sType == "H" || sType == "h") && ho_no == 2) ||
				( (sType == "V" || sType == "v") && ho_no == 2) ||
				( (sType == "A" || sType == "a") && ho_no == 8) ||
				( (sType == "C" || sType == "c") && ho_no == 7) )
			{
				gi_no++;
				ho_no = 0;

				var aHor1 = new Array();	// 2차원 배열의 가로 배열
				aGpData[gi_no] = aHor1;
				aGpData[gi_no][ho_no] = "";				
				ho_no++;
				aGpData[gi_no][ho_no] = parseInt(val);
			}
			else
			{
				aGpData[gi_no][ho_no] = parseInt(val);
			}
		}
	}

	return aGpData;
}

/*********************************************************************************************
 ★ 설명
     aGpData에 해당하는 도형을 nCx, nCy를 기준으로 nAngle만큼 회전한다.
     단, AGPData()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpData : 반드시 AGPData()에 의해 발생한 Array 
    2. nAngle : 회전각, Radian
    3. nCx : 회전 중심 X좌표
    4. nCy : 회전 중심 Y좌표
 ★ return 
    - 성공 = 회전된 2차원 Array = aGpData ( ※ aGpResetData를 바꾸어 return한다. )
    - 실패 = 빈 Array
 ★ 주의사항
    1. 메모리 낭비를 줄이기 위해 aGpData를 직접바꾸게 되므로 보관 잘 할것
    2. Parameter의 aGpData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.        
 ★ BUG    
    1. Arc로 그린놈들은 좀 이상하게 된다.
 ********************************************************************************************/
 /**************** 빼버렸음
function GPRotate( aGpData, nAngle, nCx, nCy )
{
	var i, sType;
	var aGpResetData;
	var vRot;		// Rotation좌표
	
	if( IsNull(aGpData) || IsNull(nAngle) || IsNull(nCx) || IsNull(nCy) )		
		return (new Array());

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	// 회전 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			vRot = RotatePoint(aGpResetData[i][1], aGpResetData[i][2], nCx, nCy, nAngle);
			aGpResetData[i][1] = vRot.left;
			aGpResetData[i][2] = vRot.top;
		}
		if( sType == "C" )
		{
			vRot = RotatePoint(aGpResetData[i][3], aGpResetData[i][4], nCx, nCy, nAngle);
			aGpResetData[i][3] = vRot.left;
			aGpResetData[i][4] = vRot.top;
			aRot = RotatePoint(aGpResetData[i][5], aGpResetData[i][6], nCx, nCy, nAngle);
			aGpResetData[i][5] = vRot.left;
			aGpResetData[i][6] = vRot.top;			
		}
		if( sType == "A" )
		{
			vRot = RotatePoint(aGpResetData[i][6], aGpResetData[i][7], nCx, nCy, nAngle);
			aGpResetData[i][6] = vRot.left;
			aGpResetData[i][7] = vRot.top;
		}
	}
	
	return aGpResetData;
}
************************/
/*********************************************************************************************
 ★ 설명
     aGpData에 해당하는 도형의 좌표들을 이동한다.
     단, AGPData()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpData : 반드시 AGPData()에 의해 발생한 Array 
	2. nOffsetX, nOffsetY : 현재 상태를 기준으로 이동할 X축, Y축 길이
	                 (단, 왼쪽으로 이동하려면 nOffsetX를 음수로,
	                      위쪽으로 이동하려면 nOffsetY를 음수로 주면됨)
 ★ return 
    - 성공 = 이동된 2차원 Array = aGpData ( ※ aGpResetData를 바꾸어 return한다. )
    - 실패 = 빈 Array
 ★ 주의사항
    1. 메모리 낭비를 줄이기 위해 aGpData를 직접바꾸게 되므로 보관 잘 할것
    2. Parameter의 aGpData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.    
 ********************************************************************************************/
 /********************** 빼버렸다
function GPMove( aGpData, nOffsetX, nOffsetY )
{
	var i, sType;
	
	if( IsNull(aGpData) || IsNull(nOffsetX) || IsNull(nOffsetY) )
		return (new Array() );

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	
	// 이동 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			aGpResetData[i][1] += nOffsetX;
			aGpResetData[i][2] += nOffsetY;
		}
		if( sType == "C" )
		{
			aGpResetData[i][3] += nOffsetX;
			aGpResetData[i][4] += nOffsetY;
			aGpResetData[i][5] += nOffsetX;
			aGpResetData[i][6] += nOffsetY;			
		}
		if( sType == "A" )
		{
			aGpResetData[i][6] += nOffsetX;
			aGpResetData[i][7] += nOffsetY;
		}
	}
	
	return aGpResetData;
}
***********************/

/*********************************************************************************************
 ★ Logic이 복잡해서 중단한다. 지겹다.
 ★ 설명
     aGpResetData에 해당하는 도형의 좌표들을 nCX, nCY를 중심으로 확대/축소한다.
     단, AGPReset()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpResetData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpResetData : 반드시 AGPReset()에 의해 발생한 Array 
				     ( 예 : { {M,0,0},{L,100,100} } )
	2. nOffsetX, nOffsetY : 현재 상태를 기준으로 확대/축소할 X축, Y축 길이
	                 (단, X축방향에 대해 축소하려면 nOffsetX를 음수로,
	                      Y축방향에 대해 축소하려면 nOffsetY를 음수로 주면됨)
	3. nCX, nCY     : 확대 축소할 중앙점 좌표 	                      
 ★ return 
    - 성공 = 이동된 2차원 Array = aGpResetData ( ※ aGpResetData를 바꾸어 return한다. )
             ( 예 : Array ==> { {M,0,0},{L,100,100},{L,200,100},{L,200,200},{L,300,300,200,200} }
    - 실패 = null
 ★ 주의사항
    1. Parameter의 aGpResetData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.
    2. aGpResetData자체를 바꾸게 되므로 필요시 보관절차를 취해야 한다.
 ★ BUG
    1. A(원의 경우) 반지름 처리가 정확하지 않음
 ********************************************************************************************/
/* 
function AGPResize( aGpData, nOffsetX, nOffsetY)
{

	var nCX, nCY;
	var i, j, sType;
	
	if( IsNull(aGpData) || IsNull(nOffsetX) || IsNull(nOffsetY) )
		return (new Array() );

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	
	// Center좌표 계산하기
	var nMinX=0, nMaxX=0, nMinY=0, nMaxY=0;
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			nMinX = Math.min(nMinX, aGpResetData[i][1]);
			nMaxX = Math.max(nMaxX, aGpResetData[i][1]);
			nMinY = Math.min(nMinY, aGpResetData[i][2]);
			nMaxY = Math.max(nMaxY, aGpResetData[i][2]);
		}
		if( sType == "C" )
		{
			noX[0] = 3; 	noY[0] = 4;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
			noX[1] = 5;		noY[1] = 6;	aOffsetX[1] = nOffsetX;		aOffsetY[1] = nOffsetY;
		}
		if( sType == "A" )
		{
			noX[0] = 6;		noY[0] = 7; aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
//			noX[1] = 1;		noY[1] = 2; aOffsetX[1] = nOffsetX/2;		aOffsetY[1] = nOffsetY/2;
		}
		for( j = 0 ; j < noX.length ; j++ )
		{
			if( aGpResetData[i][noX[j]] < nCX )
				aGpResetData[i][noX[j]] -= aOffsetX[j];
			if( aGpResetData[i][noX[j]] > nCX )
				aGpResetData[i][noX[j]] += aOffsetX[j];
		}
		for( j = 0 ; j < noY.length ; j++ )
		{
			if( aGpResetData[i][noY[j]] < nCY )
				aGpResetData[i][noY[j]] -= aOffsetY[j];
			if( aGpResetData[i][noY[j]] > nCY )
				aGpResetData[i][noY[j]] += aOffsetY[j];
		}
	}
	
	var noX = new Array(), noY = new Array();
	var aOffsetX = new Array(), aOffsetY = new Array();
	
	// 이동 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			noX[0] = 1;		noY[0] = 2;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
		}
		if( sType == "C" )
		{
			noX[0] = 3; 	noY[0] = 4;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
			noX[1] = 5;		noY[1] = 6;	aOffsetX[1] = nOffsetX;		aOffsetY[1] = nOffsetY;
		}
		if( sType == "A" )
		{
			noX[0] = 6;		noY[0] = 7; aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
//			noX[1] = 1;		noY[1] = 2; aOffsetX[1] = nOffsetX/2;		aOffsetY[1] = nOffsetY/2;
		}
		for( j = 0 ; j < noX.length ; j++ )
		{
			if( aGpResetData[i][noX[j]] < nCX )
				aGpResetData[i][noX[j]] -= aOffsetX[j];
			if( aGpResetData[i][noX[j]] > nCX )
				aGpResetData[i][noX[j]] += aOffsetX[j];
		}
		for( j = 0 ; j < noY.length ; j++ )
		{
			if( aGpResetData[i][noY[j]] < nCY )
				aGpResetData[i][noY[j]] -= aOffsetY[j];
			if( aGpResetData[i][noY[j]] > nCY )
				aGpResetData[i][noY[j]] += aOffsetY[j];
		}
	}
	
	return aGpResetData;
}
*/
//????
function LDBSelect(ds_obj, sel_sql)
{
}


////////////////////////////////////////////////////////////////////////////////
// Component관련 함수 End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 기타 함수 Start
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 기타 함수 End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 내부에서만 사용하는 함수 Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    Dialog(), Open()실행용 공통함수.
    ※ 단, 내부에서 사용하는 함수임     
 ★ parameter 
    1. sID     : Dialog ID ( 예 : "id1" )         
    2. sURL    : Form URL ( 예 : "Base::a.xfdl" )
    3. Arg    : Dialog 로 전달될 Argument  
                 ( 예1 : {a:'b',c:'d'}  ==> 꼭, {}로 싸야 되고 위의 예 처럼 해야 된다. )
                 ( 예2 : var arr = new Array();
						arr["a"] = "b";
						arr["c"] = "d";  ==> 이래 한 후에 arr넘김 )

    4. nLeft   : Dialog창의 Left Position ( 옵션 : Default = 현재화면 중앙 ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 현재화면 중앙에 위치)
    5. nTop    : Dialog창의 Top Position ( 옵션 : Default = 현재화면 중앙 ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 현재화면 중앙에 위치)
    6. nWidth  : Dialog창의 Width ( 옵션 : Default = Popup화면의 width ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 Popup화면의 width)
    7. nHeight : Dialog창의 Height ( 옵션 : Default = Popup화면의 height ) ( 예 : -1 또는 100 )
				 (단, 음수또는 null이면 Popup화면의 width)
    8. sStyle  : Dialog Open 기본 유형 (옵션 : Default = "" ) ( 예 : "title=true,status=true" )
                 (단, 간단히 지정하도록 처리했으므로 ChildFrame의 Property명과 동일하지는 않다.)
        - title  : Title Bar표시여부 ( Default = true ) ( true = Title Bar 표시 )
        - status : Status Bar표시여부 ( Default = true ) ( true = Status Bar 표시 )
        - close  : Close Button활성화 여부 ( Default = true ) ( true = Close Button활성화 )
        - min    : min Button활성화 여부 ( Default = true )  ( true = Min Button 활성화 )      
        - max    : min Button활성화 여부 ( Default = true )  ( true = Max Button 활성화 )              
    9. sProp   : Child Frame의 모든 Property를 Property명=Property값, Property명=Property값,... 형태로 설정한다.
                 (옵션 : Default = "") ( 예 : "titletext='a', style.border='1 solid blue', ... )
                 ( 단, sStyle에 동일한 처리가 있으면 sProp가 적용된다. 
                   즉, sStyle="title=true", sProp="showtitlebar=false"라면 Title Bar는 표시되지 않는다.
 ★ return 
    - 성공 = Child Frame Object
    - 실패 = null
 ★ 주의사항
    1. nLeft, nTop이 null이거나 음수이면 현재화면의 중앙에 위치함
    2. nWidth, nHeight이 하나라도 null이거나 음수이면 Popup화면의 width, height가 설정됨
       따라서, nWidth, nHeight를 설정하고 싶으면 두 값 모두 양수값을 확실히 설정해야 한다.
    3. 조금더, 자세하게 Popup화면을 제어하고 싶으면 ( 예를 들어, scrollbar, border등 )
       sProp에 지정하거나 Dialog창의 Frame을 얻어 직접제어할 것
    4. nLeft, nTop, nWidth, nHeight의 좌표계는 screen기준 좌표계임에 주의할것       
 ★ Bug
    1. sStyle에서 2009.12.10일 현재 min, max, status 잘안됨(???(모름 - Theme때문인가?))
    2. bAutoSize = true인 경우 Popup창의 position을 체크하면 값이 잘 안나옴(???(모름))
    3. ChildFrame.init()에서 좌표처리에 BUG있음(???(모름))
    4. ChildFrame.resizable=true 안먹네(???(모름))
 ******************************************************************************/
function _NewChildFrame( sID, sURL, Arg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var newChild = null;
	var MyFrame = this.getOwnerFrame();
	
	var bTitle = true;
	var bStatus = true;
	var bClose = true;
	var bMin = true;
	var bMax = true;	
	var bAutoSize = true;	
	var flag;
	var aProp = new Array();

	if( IsNull(sID) || IsNull(sURL) )	return null;
	
	newChild = new ChildFrame;
		
	if( IsNull(nLeft) || nLeft < 0 )
		newChild.openalign.halign = "center";
	if( IsNull(nTop) || nTop < 0 )
		newChild.openalign.valign = "center";
	if( IsNull(nWidth) || nWidth < 0 ||
	    IsNull(nHeight) || nHeight < 0 )
	{
		nWidth = 0;
		nHeight = 0;
		bAutoSize = true;
	}
	else
		bAutoSize = false;
	if( IsNull(sStyle) == false )
	{
		var i, arr, arr1;
		arr = sStyle.split(",");
		for( i = 0 ; i < arr.length ; i++ )
		{
			arr1 = arr[i].split("=");
			arr1[0] = RTrim(LTrim(arr1[0]));
			arr1[1] = RTrim(LTrim(arr1[1]));		
			if( arr1[1].toLowerCase() == "true" )		flag = true;
			else										flag = false;
			
			if( arr1[0].toLowerCase() == "title" ) 		bTitle = flag;
			if( arr1[0].toLowerCase() == "status" ) 	bStatus = flag;
			if( arr1[0].toLowerCase() == "close" ) 		bClose = flag;			
			if( arr1[0].toLowerCase() == "min" ) 		bMin = flag;			
			if( arr1[0].toLowerCase() == "max" ) 		bMax = flag;						
		}
	}

	if( IsNull(sProp) == false )
	{
		var i;
		aProp = sProp.split(",");
		for( i = 0 ; i < aProp.length ; i++ )
		{
			aProp[i] = aProp[i].split("=");
			aProp[i][0] = RTrim(LTrim(aProp[i][0]));
			aProp[i][1] = RTrim(LTrim(aProp[i][1]));
		}
	}

	newChild.formurl = sURL;	
	
	////// sStyle내용 적용( 이부분은 init()호출전에 사용해야 함 )
	newChild.showtitlebar = bTitle;	
	newChild.showstatusbar = bStatus;			
	newChild.autosize = bAutoSize;
	
	newChild.init(sID, nLeft, nTop, nLeft + nWidth, nTop + nHeight);

	////// sStyle내용 적용( 이부분은 init()호출후에 사용해야 함 )
	newChild.titlebar.minbutton.enable = bMin;		
	newChild.titlebar.maxbutton.enable = bMax;		
	newChild.titlebar.closebutton.enable = bClose;	

	MyFrame.addChild(sID, newChild);	// 이거 꼭 해야 함
	////// sProp내용 적용
	for( i = 0 ; i < aProp.length ; i++ )
	{
		SetProp( "this.getOwnerFrame()."+sID, aProp[i][0], aProp[i][1] );
	}
	MyFrame.removeChild(sID);			// 이거 꼭 해야 함

	return newChild;
}

/*******************************************************************************
 ★ 설명
     각 월별 음력 기준 정보를 처리하는 함수(처리가능 기간  1841 - 2043년)
     단, 내부에서 사용하는 함수임     
 ★ parameter 
    1. 없음
 ★ return 
    - 성공 = 음력 기준정보
    - 실패 = 
 ******************************************************************************/
function _SolarBase()
{
	var kk;
	
	//1841
	kk = "1,2,4,1,1,2,1,2,1,2,2,1,";
	kk += "2,2,1,2,1,1,2,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,4,1,2,1,2,1,";
	kk += "2,2,1,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,5,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,3,2,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	//1851
	kk += "2,2,1,2,1,1,2,1,2,1,5,2,";
	kk += "2,1,2,2,1,1,2,1,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,5,2,1,2,1,2,";
	kk += "1,1,2,1,2,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,5,2,1,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,6,1,1,2,1,1,2,1,2,2,";
	//1861
	kk += "1,2,2,1,2,1,2,1,2,1,1,2,";
	kk += "2,1,2,1,2,2,1,2,2,3,1,2,";
	kk += "1,2,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,4,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,1,2,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,3,2,1,1,2,1,2,2,1,";
	kk += "2,2,2,1,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,5,2,1,";
	//1871
	kk += "2,2,1,2,2,1,2,1,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,4,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,5,1,2,1,2,2,1,2,";
	kk += "2,2,1,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,4,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,1,2,";
	//1881
	kk += "1,2,1,2,1,2,5,2,2,1,2,1,";
	kk += "1,2,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,3,2,1,2,2,1,2,2,";
	kk += "2,1,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,5,2,1,1,2,1,2,1,2,";
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,5,2,1,2,2,1,2,1,2,1,2,";
	//1891
	kk += "1,2,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,5,2,2,1,2,2,2,";
	kk += "1,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,5,1,2,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,5,2,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,5,2,2,1,2,";
	//1901
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,3,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,4,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,5,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	//1911
	kk += "2,1,2,1,1,5,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,5,1,2,1,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,3,2,1,2,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,5,2,2,1,2,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	//1921
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,2,2,3,2,1,1,2,1,2,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,1,2,";
	kk += "2,1,2,1,2,2,1,2,1,2,1,1,";
	kk += "2,1,2,5,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,5,1,2,1,1,2,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,1,1,5,1,2,1,2,2,1,";
	//1931
	kk += "2,2,2,1,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,6,1,2,1,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,4,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,2,1,4,1,2,2,1,2,";
	kk += "2,2,1,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	//1941
	kk += "2,2,1,2,2,4,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,1,2,4,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,1,1,2,1,2,2,1,2,";
	kk += "2,5,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,3,2,1,2,1,2,";
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	//1951
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,4,2,1,2,1,2,1,2,";
	kk += "1,2,1,1,2,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,1,2,2,";
	kk += "2,1,4,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,5,2,1,2,2,";
	kk += "1,2,2,1,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,5,2,1,2,1,2,1,";
	//1961
	kk += "2,1,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,2,3,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,5,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,5,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,2,1,2,1,2,2,1,2,";
	//1971
	kk += "1,2,1,1,5,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,1,2,2,2,1,";
	kk += "2,2,1,5,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,5,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,1,";
	kk += "2,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,1,6,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	//1981
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,3,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,2,2,1,1,2,1,1,5,2,2,";
	kk += "1,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,2,2,1,2,1,2,1,1,";
	kk += "2,1,2,2,1,5,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,2,1,1,5,1,2,1,2,2,2,2,";
	//1991
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,1,1,2,1,1,2,1,2,2,";
	kk += "1,2,5,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,2,2,1,5,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,3,2,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,2,1,1,2,1,2,2,1,";
	//2001
	kk += "2,2,2,3,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,1,2,2,1,2,1,1,2,1,2,";
	kk += "1,5,2,2,1,2,1,2,2,1,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,5,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,1,1,2,1,2,2,1,2,";
	kk += "2,2,1,1,5,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	//2011
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,6,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,1,2,5,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,1,2,2,";
	kk += "2,1,1,2,3,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,1,2,5,2,1,1,2,1,2,1,2,";
	//2021
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,2,1,2,1,2,1,2,";
	kk += "1,5,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,2,1,1,5,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,1,2,2,2,";
	kk += "1,2,2,1,5,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,1,2,2,";
	kk += "1,2,1,2,2,1,2,1,2,1,2,1,";
	//2031
	kk += "2,1,5,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,2,1,1,2,1,5,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,4,1,1,2,1,2,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,2,1,1,2,1,";
	kk += "2,2,1,2,5,2,1,2,1,2,1,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,2,1,";
	//2041
	kk += "2,1,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,5,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2";
	
	var arr = new Array();
	arr = kk.split(",");
	
	return arr;
}

/*******************************************************************************
 ★ 설명
     Named Color List
     단, 내부에서 사용하는 함수임     
 ★ parameter 
    1. 없음
 ★ return 
    - 성공 = Named Color 2차원 Array 
			(예 : Array[0][0] = "blue", Array[0][1] = "#0000FF")
    - 실패 = 
 ******************************************************************************/
function _NamedColor()
{
	var kk="";
	
	kk += "aliceblue,#F0F8FF\n";
	kk += "antiquewhite,#FAEBD7\n";
	kk += "aqua,#00FFFF\n";
	kk += "aquamarine,#7FFFD4\n";
	kk += "azure,#F0FFFF\n";
	kk += "beige,#F5F5DC\n";
	kk += "bisque,#FFE4C4\n";
	kk += "black,#000000\n";
	kk += "blanchedalmond,#FFEBCD\n";
	kk += "blue,#0000FF\n";
	kk += "blueviolet,#8A2BE2\n";
	kk += "brown,#A52A2A\n";
	kk += "burlywood,#DEB887\n";
	kk += "cadetblue,#5F9EA0\n";
	kk += "chartreuse,#7FFF00\n";
	kk += "chocolate,#D2691E\n";
	kk += "coral,#FF7F50\n";
	kk += "cornflowerblue,#6495ED\n";
	kk += "cornsilk,#FFF8DC\n";
	kk += "crimson,#DC143C\n";
	kk += "cyan,#00FFFF\n";
	kk += "darkblue,#00008B\n";
	kk += "darkcyan,#008B8B\n";
	kk += "darkgoldenrod,#B8860B\n";
	kk += "darkgray,#A9A9A9\n";
	kk += "darkgreen,#006400\n";
	kk += "darkgrey,#A9A9A9\n";
	kk += "darkkhaki,#BDB76B\n";
	kk += "darkmagenta,#8B008B\n";
	kk += "darkolivegreen,#556B2F\n";
	kk += "darkorange,#FF8C00\n";
	kk += "darkorchid,#9932CC\n";
	kk += "darkred,#8B0000\n";
	kk += "darksalmon,#E9967A\n";
	kk += "darkseagreen,#8FBC8F\n";
	kk += "darkslateblue,#483D8B\n";
	kk += "darkslategray,#2F4F4F\n";
	kk += "darkslategrey,#2F4F4F\n";
	kk += "darkturquoise,#00CED1\n";
	kk += "darkviolet,#9400D3\n";
	kk += "deeppink,#FF1493\n";
	kk += "deepskyblue,#00BFFF\n";
	kk += "dimgray,#696969\n";
	kk += "dimgrey,#696969\n";
	kk += "dodgerblue,#1E90FF\n";
	kk += "firebrick,#B22222\n";
	kk += "floralwhite,#FFFAF0\n";
	kk += "forestgreen,#228B22\n";
	kk += "fuchsia,#FF00FF\n";
	kk += "gainsboro,#DCDCDC\n";
	kk += "ghostwhite,#F8F8FF\n";
	kk += "gold,#FFD700\n";
	kk += "goldenrod,#DAA520\n";
	kk += "gray,#808080\n";
	kk += "green,#008000\n";
	kk += "greenyellow,#ADFF2F\n";
	kk += "grey,#808080\n";
	kk += "honeydew,#F0FFF0\n";
	kk += "hotpink,#FF69B4\n";
	kk += "indianred,#CD5C5C\n";
	kk += "indigo,#4B0082\n";
	kk += "ivory,#FFFFF0\n";
	kk += "khaki,#F0E68C\n";
	kk += "lavender,#E6E6FA\n";
	kk += "lavenderblush,#FFF0F5\n";
	kk += "lawngreen,#7CFC00\n";
	kk += "lemonchiffon,#FFFACD\n";
	kk += "lightblue,#ADD8E6\n";
	kk += "lightcoral,#F08080\n";
	kk += "lightcyan,#E0FFFF\n";
	kk += "lightgoldenrodyellow,#FAFAD2\n";
	kk += "lightgray,#D3D3D3\n";
	kk += "lightgreen,#90EE90\n";
	kk += "lightgrey,#D3D3D3\n";
	kk += "lightpink,#FFB6C1\n";
	kk += "lightsalmon,#FFA07A\n";
	kk += "lightseagreen,#20B2AA\n";
	kk += "lightskyblue,#87CEFA\n";
	kk += "lightslategray,#778899\n";
	kk += "lightslategrey,#778899\n";
	kk += "lightsteelblue,#B0C4DE\n";
	kk += "lightyellow,#FFFFE0\n";
	kk += "lime,#00FF00\n";
	kk += "limegreen,#32CD32\n";
	kk += "linen,#FAF0E6\n";
	kk += "magenta,#FF00FF\n";
	kk += "maroon,#800000\n";
	kk += "mediumaquamarine,#66CDAA\n";
	kk += "mediumblue,#0000CD\n";
	kk += "mediumorchid,#BA55D3\n";
	kk += "mediumpurple,#9370DB\n";
	kk += "mediumseagreen,#3CB371\n";
	kk += "mediumslateblue,#7B68EE\n";
	kk += "mediumspringgreen,#00FA9A\n";
	kk += "mediumturquoise,#48D1CC\n";
	kk += "mediumvioletred,#C71585\n";
	kk += "midnightblue,#191970\n";
	kk += "mintcream,#F5FFFA\n";
	kk += "mistyrose,#FFE4E1\n";
	kk += "moccasin,#FFE4B5\n";
	kk += "navajowhite,#FFDEAD\n";
	kk += "navy,#000080\n";
	kk += "oldlace,#FDF5E6\n";
	kk += "olive,#808000\n";
	kk += "olivedrab,#6B8E23\n";
	kk += "orange,#FFA500\n";
	kk += "orangered,#FF4500\n";
	kk += "orchid,#DA70D6\n";
	kk += "palegoldenrod,#EEE8AA\n";
	kk += "palegreen,#98FB98\n";
	kk += "paleturquoise,#AFEEEE\n";
	kk += "palevioletred,#DB7093\n";
	kk += "papayawhip,#FFEFD5\n";
	kk += "peachpuff,#FFDAB9\n";
	kk += "peru,#CD853F\n";
	kk += "pink,#FFC0CB\n";
	kk += "plum,#DDA0DD\n";
	kk += "powderblue,#B0E0E6\n";
	kk += "purple,#800080\n";
	kk += "red,#FF0000\n";
	kk += "rosybrown,#BC8F8F\n";
	kk += "royalblue,#4169E1\n";
	kk += "saddlebrown,#8B4513\n";
	kk += "salmon,#FA8072\n";
	kk += "sandybrown,#F4A460\n";
	kk += "seagreen,#2E8B57\n";
	kk += "seashell,#FFF5EE\n";
	kk += "sienna,#A0522D\n";
	kk += "silver,#C0C0C0\n";
	kk += "skyblue,#87CEEB\n";
	kk += "slateblue,#6A5ACD\n";
	kk += "slategray,#708090\n";
	kk += "slategrey,#708090\n";
	kk += "snow,#FFFAFA\n";
	kk += "springgreen,#00FF7F\n";
	kk += "steelblue,#4682B4\n";
	kk += "tan,#D2B48C\n";
	kk += "teal,#008080\n";
	kk += "thistle,#D8BFD8\n";
	kk += "tomato,#FF6347\n";
	kk += "turquoise,#40E0D0\n";
	kk += "violet,#EE82EE\n";
	kk += "wheat,#F5DEB3\n";
	kk += "white,#FFFFFF\n";
	kk += "whitesmoke,#F5F5F5\n";
	kk += "yellow,#FFFF00\n";
	kk += "yellowgreen,#9ACD32\n";

	var aColor = new Array();
	var i;
	
	aColor = kk.split("\n");
	for( i = 0 ; i < aColor.length ; i++ )
	{
		var arr;
		arr = aColor[i].split(",");
		aColor[i] = arr;
	}
	
	return aColor;
}

/*********************************************************************************************
 ★ 설명
     AGPData()에 의해 발생한 Array를 절대좌표로, H,h,V,v를 L로 변환하여 2차원 Array를 설정한다.
     단, aGpData자체를 바꾸게 된다.
     단, 내부에서만 사용하는 함수임
 ★ parameter 
    1. aGpData : AGPData()에 의해 발생한 Array 
				( 예 : { {M,0,0},{L,100,100},{H,200},{V,200},{l,100,100,-100,-100} } )
 ★ return 
    - 성공 = 2차원 Array 
             ( 예 : Array ==> { {M,0,0},{L,100,100},{L,200,100},{L,200,200},{L,300,300,200,200} }
    - 실패 = 빈 Array
 ★ 목적    
    회전, Resizing등을 할 경우 AGPData()로는 처리가 복잡해서 만들었다.
 ★ 주의사항
    Resource를 많이 사용하지 않기 위하여 Parameter로 전달된 aGpData를 직접 바꾼다.
    따라서, aGpData를 보관하고 싶다면 따로 보관처리를 해야만 한다.
 ********************************************************************************************/
function _AGPReset( aGpData )
{
	var i, j, sType, sOldType;
	var vTracePoint = new Rect();	// V, H의 좌표 추적용도	
	vTracePoint.left = 0;		vTracePoint.top = 0;

	if( IsNull(aGpData) ) 	
		return( new Array() );

	for( i = 0 ; i < aGpData.length ; i++ )
	{
		sType = aGpData[i][0];
		if( sType == "" )
		{
			sType = sOldType;
			aGpData[i][0] = sType;
		}
		if( sType == "M" )
		{
			vTracePoint.left = aGpData[i][1];
			vTracePoint.top = aGpData[i][2];
		}
		if( sType == "m" )
		{
			aGpData[i][0] = "M";		
			vTracePoint.left = vTracePoint.left + aGpData[i][1];
			vTracePoint.top = vTracePoint.top + aGpData[i][2];
			aGpData[i][1] = vTracePoint.left;
			aGpData[i][2] = vTracePoint.top;			
		}
		if( sType == "L" )
		{
			vTracePoint.left = aGpData[i][1];
			vTracePoint.top = aGpData[i][2];
		}
		if( sType == "l" )
		{
			aGpData[i][0] = "L";				
			vTracePoint.left = vTracePoint.left + aGpData[i][1];
			vTracePoint.top = vTracePoint.top + aGpData[i][2];
			aGpData[i][1] = vTracePoint.left;
			aGpData[i][2] = vTracePoint.top;			
		}
		if( sType == "H" )
		{
			aGpData[i][0] = "L";		
			vTracePoint.left = aGpData[i][1];
			vTracePoint.top = vTracePoint.top;		
			aGpData[i][1] = vTracePoint.left;			
			aGpData[i][2] = vTracePoint.top;			
		}		
		if( sType == "h" )
		{
			aGpData[i][0] = "L";
			vTracePoint.left = vTracePoint.left + aGpData[i][1];
			vTracePoint.top = vTracePoint.top;			
			aGpData[i][1] = vTracePoint.left;
			aGpData[i][2] = vTracePoint.top;			
		}
		if( sType == "V" )
		{
			aGpData[i][0] = "L";				
			vTracePoint.left = vTracePoint.left;
			vTracePoint.top = aGpData[i][1];		
			aGpData[i][1] = vTracePoint.left;
			aGpData[i][2] = vTracePoint.top;			
		}		
		if( sType == "v" )
		{
			aGpData[i][0] = "L";		
			vTracePoint[0] = vTracePoint.left;
			vTracePoint[1] = vTracePoint.top + aGpData[i][1];		
			aGpData[i][1] = vTracePoint.left;
			aGpData[i][2] = vTracePoint.top;			
		}		
		if( sType == "A" )
		{
			vTracePoint.left = aGpData[i][6];
			vTracePoint.top = aGpData[i][7];
		}	
		if( sType == "a" )
		{
			aGpData[i][0] = "A";				
			vTracePoint.left = vTracePoint.left + aGpData[i][6];
			vTracePoint.top = vTracePoint.top + aGpData[i][7];
			aGpData[i][6] = vTracePoint.left;
			aGpData[i][7] = vTracePoint.top;				
		}	
		if( sType == "C" )
		{
			vTracePoint.left = aGpData[i][5];
			vTracePoint.top = aGpData[i][6];
		}
		if( sType == "c" )
		{
			aGpData[i][0] = "C";
			aGpData[i][1] = vTracePoint.left + aGpData[i][1];
			aGpData[i][2] = vTracePoint.top + aGpData[i][2]				
			aGpData[i][3] = vTracePoint.left + aGpData[i][3];
			aGpData[i][4] = vTracePoint.top + aGpData[i][4]				
			aTracePoint[0] = vTracePoint.left + aGpData[i][5];
			aTracePoint[1] = vTracePoint.top + aGpData[i][6];
			aGpData[i][5] = vTracePoint.left;
			aGpData[i][6] = vTracePoint.top;				
		}
		sOldType = sType;
	}

	return aGpData;
}
////////////////////////////////////////////////////////////////////////////////
// 내부에서만 사용하는 함수 End
////////////////////////////////////////////////////////////////////////////////

]]></Script>
